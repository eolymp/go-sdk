// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: eolymp/l10n/localization_service.proto

package l10n

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	LocalizationService_CreateTerm_FullMethodName           = "/eolymp.l10n.LocalizationService/CreateTerm"
	LocalizationService_ListTerms_FullMethodName            = "/eolymp.l10n.LocalizationService/ListTerms"
	LocalizationService_UpdateTerm_FullMethodName           = "/eolymp.l10n.LocalizationService/UpdateTerm"
	LocalizationService_RestoreTerm_FullMethodName          = "/eolymp.l10n.LocalizationService/RestoreTerm"
	LocalizationService_DeprecateTerm_FullMethodName        = "/eolymp.l10n.LocalizationService/DeprecateTerm"
	LocalizationService_DeleteTerm_FullMethodName           = "/eolymp.l10n.LocalizationService/DeleteTerm"
	LocalizationService_DescribeTerm_FullMethodName         = "/eolymp.l10n.LocalizationService/DescribeTerm"
	LocalizationService_ImportTerms_FullMethodName          = "/eolymp.l10n.LocalizationService/ImportTerms"
	LocalizationService_AddLocale_FullMethodName            = "/eolymp.l10n.LocalizationService/AddLocale"
	LocalizationService_RemoveLocale_FullMethodName         = "/eolymp.l10n.LocalizationService/RemoveLocale"
	LocalizationService_ListLocales_FullMethodName          = "/eolymp.l10n.LocalizationService/ListLocales"
	LocalizationService_TranslateTerm_FullMethodName        = "/eolymp.l10n.LocalizationService/TranslateTerm"
	LocalizationService_ListTranslations_FullMethodName     = "/eolymp.l10n.LocalizationService/ListTranslations"
	LocalizationService_DeleteTranslation_FullMethodName    = "/eolymp.l10n.LocalizationService/DeleteTranslation"
	LocalizationService_SuggestTranslation_FullMethodName   = "/eolymp.l10n.LocalizationService/SuggestTranslation"
	LocalizationService_UpdateTranslation_FullMethodName    = "/eolymp.l10n.LocalizationService/UpdateTranslation"
	LocalizationService_ApproveTranslation_FullMethodName   = "/eolymp.l10n.LocalizationService/ApproveTranslation"
	LocalizationService_RejectTranslation_FullMethodName    = "/eolymp.l10n.LocalizationService/RejectTranslation"
	LocalizationService_ImportTranslations_FullMethodName   = "/eolymp.l10n.LocalizationService/ImportTranslations"
	LocalizationService_ExportTranslations_FullMethodName   = "/eolymp.l10n.LocalizationService/ExportTranslations"
	LocalizationService_ListTranslationPairs_FullMethodName = "/eolymp.l10n.LocalizationService/ListTranslationPairs"
)

// LocalizationServiceClient is the client API for LocalizationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocalizationServiceClient interface {
	CreateTerm(ctx context.Context, in *CreateTermInput, opts ...grpc.CallOption) (*CreateTermOutput, error)
	ListTerms(ctx context.Context, in *ListTermsInput, opts ...grpc.CallOption) (*ListTermsOutput, error)
	UpdateTerm(ctx context.Context, in *UpdateTermInput, opts ...grpc.CallOption) (*UpdateTermOutput, error)
	RestoreTerm(ctx context.Context, in *RestoreTermInput, opts ...grpc.CallOption) (*RestoreTermOutput, error)
	DeprecateTerm(ctx context.Context, in *DeprecateTermInput, opts ...grpc.CallOption) (*DeprecateTermOutput, error)
	DeleteTerm(ctx context.Context, in *DeleteTermInput, opts ...grpc.CallOption) (*DeleteTermOutput, error)
	DescribeTerm(ctx context.Context, in *DescribeTermInput, opts ...grpc.CallOption) (*DescribeTermOutput, error)
	ImportTerms(ctx context.Context, in *ImportTermsInput, opts ...grpc.CallOption) (*ImportTermsOutput, error)
	AddLocale(ctx context.Context, in *AddLocaleInput, opts ...grpc.CallOption) (*AddLocaleOutput, error)
	RemoveLocale(ctx context.Context, in *RemoveLocaleInput, opts ...grpc.CallOption) (*RemoveLocaleOutput, error)
	ListLocales(ctx context.Context, in *ListLocalesInput, opts ...grpc.CallOption) (*ListLocalesOutput, error)
	TranslateTerm(ctx context.Context, in *TranslateTermInput, opts ...grpc.CallOption) (*TranslateTermOutput, error)
	ListTranslations(ctx context.Context, in *ListTranslationsInput, opts ...grpc.CallOption) (*ListTranslationsOutput, error)
	DeleteTranslation(ctx context.Context, in *DeleteTranslationInput, opts ...grpc.CallOption) (*DeleteTranslationOutput, error)
	SuggestTranslation(ctx context.Context, in *SuggestTranslationInput, opts ...grpc.CallOption) (*SuggestTranslationOutput, error)
	UpdateTranslation(ctx context.Context, in *UpdateTranslationInput, opts ...grpc.CallOption) (*UpdateTranslationOutput, error)
	ApproveTranslation(ctx context.Context, in *ApproveTranslationInput, opts ...grpc.CallOption) (*ApproveTranslationOutput, error)
	RejectTranslation(ctx context.Context, in *RejectTranslationInput, opts ...grpc.CallOption) (*RejectTranslationOutput, error)
	ImportTranslations(ctx context.Context, in *ImportTranslationsInput, opts ...grpc.CallOption) (*ImportTranslationsOutput, error)
	ExportTranslations(ctx context.Context, in *ExportTranslationsInput, opts ...grpc.CallOption) (*ExportTranslationsOutput, error)
	ListTranslationPairs(ctx context.Context, in *ListTranslationPairsInput, opts ...grpc.CallOption) (*ListTranslationPairsOutput, error)
}

type localizationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLocalizationServiceClient(cc grpc.ClientConnInterface) LocalizationServiceClient {
	return &localizationServiceClient{cc}
}

func (c *localizationServiceClient) CreateTerm(ctx context.Context, in *CreateTermInput, opts ...grpc.CallOption) (*CreateTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_CreateTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ListTerms(ctx context.Context, in *ListTermsInput, opts ...grpc.CallOption) (*ListTermsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTermsOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ListTerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) UpdateTerm(ctx context.Context, in *UpdateTermInput, opts ...grpc.CallOption) (*UpdateTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_UpdateTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) RestoreTerm(ctx context.Context, in *RestoreTermInput, opts ...grpc.CallOption) (*RestoreTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_RestoreTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) DeprecateTerm(ctx context.Context, in *DeprecateTermInput, opts ...grpc.CallOption) (*DeprecateTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeprecateTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_DeprecateTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) DeleteTerm(ctx context.Context, in *DeleteTermInput, opts ...grpc.CallOption) (*DeleteTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_DeleteTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) DescribeTerm(ctx context.Context, in *DescribeTermInput, opts ...grpc.CallOption) (*DescribeTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_DescribeTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ImportTerms(ctx context.Context, in *ImportTermsInput, opts ...grpc.CallOption) (*ImportTermsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportTermsOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ImportTerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) AddLocale(ctx context.Context, in *AddLocaleInput, opts ...grpc.CallOption) (*AddLocaleOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddLocaleOutput)
	err := c.cc.Invoke(ctx, LocalizationService_AddLocale_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) RemoveLocale(ctx context.Context, in *RemoveLocaleInput, opts ...grpc.CallOption) (*RemoveLocaleOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveLocaleOutput)
	err := c.cc.Invoke(ctx, LocalizationService_RemoveLocale_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ListLocales(ctx context.Context, in *ListLocalesInput, opts ...grpc.CallOption) (*ListLocalesOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLocalesOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ListLocales_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) TranslateTerm(ctx context.Context, in *TranslateTermInput, opts ...grpc.CallOption) (*TranslateTermOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TranslateTermOutput)
	err := c.cc.Invoke(ctx, LocalizationService_TranslateTerm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ListTranslations(ctx context.Context, in *ListTranslationsInput, opts ...grpc.CallOption) (*ListTranslationsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTranslationsOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ListTranslations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) DeleteTranslation(ctx context.Context, in *DeleteTranslationInput, opts ...grpc.CallOption) (*DeleteTranslationOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTranslationOutput)
	err := c.cc.Invoke(ctx, LocalizationService_DeleteTranslation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) SuggestTranslation(ctx context.Context, in *SuggestTranslationInput, opts ...grpc.CallOption) (*SuggestTranslationOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuggestTranslationOutput)
	err := c.cc.Invoke(ctx, LocalizationService_SuggestTranslation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) UpdateTranslation(ctx context.Context, in *UpdateTranslationInput, opts ...grpc.CallOption) (*UpdateTranslationOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTranslationOutput)
	err := c.cc.Invoke(ctx, LocalizationService_UpdateTranslation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ApproveTranslation(ctx context.Context, in *ApproveTranslationInput, opts ...grpc.CallOption) (*ApproveTranslationOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveTranslationOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ApproveTranslation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) RejectTranslation(ctx context.Context, in *RejectTranslationInput, opts ...grpc.CallOption) (*RejectTranslationOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RejectTranslationOutput)
	err := c.cc.Invoke(ctx, LocalizationService_RejectTranslation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ImportTranslations(ctx context.Context, in *ImportTranslationsInput, opts ...grpc.CallOption) (*ImportTranslationsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportTranslationsOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ImportTranslations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ExportTranslations(ctx context.Context, in *ExportTranslationsInput, opts ...grpc.CallOption) (*ExportTranslationsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportTranslationsOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ExportTranslations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localizationServiceClient) ListTranslationPairs(ctx context.Context, in *ListTranslationPairsInput, opts ...grpc.CallOption) (*ListTranslationPairsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTranslationPairsOutput)
	err := c.cc.Invoke(ctx, LocalizationService_ListTranslationPairs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocalizationServiceServer is the server API for LocalizationService service.
// All implementations should embed UnimplementedLocalizationServiceServer
// for forward compatibility
type LocalizationServiceServer interface {
	CreateTerm(context.Context, *CreateTermInput) (*CreateTermOutput, error)
	ListTerms(context.Context, *ListTermsInput) (*ListTermsOutput, error)
	UpdateTerm(context.Context, *UpdateTermInput) (*UpdateTermOutput, error)
	RestoreTerm(context.Context, *RestoreTermInput) (*RestoreTermOutput, error)
	DeprecateTerm(context.Context, *DeprecateTermInput) (*DeprecateTermOutput, error)
	DeleteTerm(context.Context, *DeleteTermInput) (*DeleteTermOutput, error)
	DescribeTerm(context.Context, *DescribeTermInput) (*DescribeTermOutput, error)
	ImportTerms(context.Context, *ImportTermsInput) (*ImportTermsOutput, error)
	AddLocale(context.Context, *AddLocaleInput) (*AddLocaleOutput, error)
	RemoveLocale(context.Context, *RemoveLocaleInput) (*RemoveLocaleOutput, error)
	ListLocales(context.Context, *ListLocalesInput) (*ListLocalesOutput, error)
	TranslateTerm(context.Context, *TranslateTermInput) (*TranslateTermOutput, error)
	ListTranslations(context.Context, *ListTranslationsInput) (*ListTranslationsOutput, error)
	DeleteTranslation(context.Context, *DeleteTranslationInput) (*DeleteTranslationOutput, error)
	SuggestTranslation(context.Context, *SuggestTranslationInput) (*SuggestTranslationOutput, error)
	UpdateTranslation(context.Context, *UpdateTranslationInput) (*UpdateTranslationOutput, error)
	ApproveTranslation(context.Context, *ApproveTranslationInput) (*ApproveTranslationOutput, error)
	RejectTranslation(context.Context, *RejectTranslationInput) (*RejectTranslationOutput, error)
	ImportTranslations(context.Context, *ImportTranslationsInput) (*ImportTranslationsOutput, error)
	ExportTranslations(context.Context, *ExportTranslationsInput) (*ExportTranslationsOutput, error)
	ListTranslationPairs(context.Context, *ListTranslationPairsInput) (*ListTranslationPairsOutput, error)
}

// UnimplementedLocalizationServiceServer should be embedded to have forward compatible implementations.
type UnimplementedLocalizationServiceServer struct {
}

func (UnimplementedLocalizationServiceServer) CreateTerm(context.Context, *CreateTermInput) (*CreateTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) ListTerms(context.Context, *ListTermsInput) (*ListTermsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTerms not implemented")
}
func (UnimplementedLocalizationServiceServer) UpdateTerm(context.Context, *UpdateTermInput) (*UpdateTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) RestoreTerm(context.Context, *RestoreTermInput) (*RestoreTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) DeprecateTerm(context.Context, *DeprecateTermInput) (*DeprecateTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeprecateTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) DeleteTerm(context.Context, *DeleteTermInput) (*DeleteTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) DescribeTerm(context.Context, *DescribeTermInput) (*DescribeTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) ImportTerms(context.Context, *ImportTermsInput) (*ImportTermsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportTerms not implemented")
}
func (UnimplementedLocalizationServiceServer) AddLocale(context.Context, *AddLocaleInput) (*AddLocaleOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLocale not implemented")
}
func (UnimplementedLocalizationServiceServer) RemoveLocale(context.Context, *RemoveLocaleInput) (*RemoveLocaleOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLocale not implemented")
}
func (UnimplementedLocalizationServiceServer) ListLocales(context.Context, *ListLocalesInput) (*ListLocalesOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocales not implemented")
}
func (UnimplementedLocalizationServiceServer) TranslateTerm(context.Context, *TranslateTermInput) (*TranslateTermOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TranslateTerm not implemented")
}
func (UnimplementedLocalizationServiceServer) ListTranslations(context.Context, *ListTranslationsInput) (*ListTranslationsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTranslations not implemented")
}
func (UnimplementedLocalizationServiceServer) DeleteTranslation(context.Context, *DeleteTranslationInput) (*DeleteTranslationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTranslation not implemented")
}
func (UnimplementedLocalizationServiceServer) SuggestTranslation(context.Context, *SuggestTranslationInput) (*SuggestTranslationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestTranslation not implemented")
}
func (UnimplementedLocalizationServiceServer) UpdateTranslation(context.Context, *UpdateTranslationInput) (*UpdateTranslationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTranslation not implemented")
}
func (UnimplementedLocalizationServiceServer) ApproveTranslation(context.Context, *ApproveTranslationInput) (*ApproveTranslationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveTranslation not implemented")
}
func (UnimplementedLocalizationServiceServer) RejectTranslation(context.Context, *RejectTranslationInput) (*RejectTranslationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectTranslation not implemented")
}
func (UnimplementedLocalizationServiceServer) ImportTranslations(context.Context, *ImportTranslationsInput) (*ImportTranslationsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportTranslations not implemented")
}
func (UnimplementedLocalizationServiceServer) ExportTranslations(context.Context, *ExportTranslationsInput) (*ExportTranslationsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportTranslations not implemented")
}
func (UnimplementedLocalizationServiceServer) ListTranslationPairs(context.Context, *ListTranslationPairsInput) (*ListTranslationPairsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTranslationPairs not implemented")
}

// UnsafeLocalizationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocalizationServiceServer will
// result in compilation errors.
type UnsafeLocalizationServiceServer interface {
	mustEmbedUnimplementedLocalizationServiceServer()
}

func RegisterLocalizationServiceServer(s grpc.ServiceRegistrar, srv LocalizationServiceServer) {
	s.RegisterService(&LocalizationService_ServiceDesc, srv)
}

func _LocalizationService_CreateTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).CreateTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_CreateTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).CreateTerm(ctx, req.(*CreateTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ListTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTermsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ListTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ListTerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ListTerms(ctx, req.(*ListTermsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_UpdateTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).UpdateTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_UpdateTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).UpdateTerm(ctx, req.(*UpdateTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_RestoreTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).RestoreTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_RestoreTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).RestoreTerm(ctx, req.(*RestoreTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_DeprecateTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeprecateTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).DeprecateTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_DeprecateTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).DeprecateTerm(ctx, req.(*DeprecateTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_DeleteTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).DeleteTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_DeleteTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).DeleteTerm(ctx, req.(*DeleteTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_DescribeTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).DescribeTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_DescribeTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).DescribeTerm(ctx, req.(*DescribeTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ImportTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportTermsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ImportTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ImportTerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ImportTerms(ctx, req.(*ImportTermsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_AddLocale_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLocaleInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).AddLocale(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_AddLocale_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).AddLocale(ctx, req.(*AddLocaleInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_RemoveLocale_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveLocaleInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).RemoveLocale(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_RemoveLocale_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).RemoveLocale(ctx, req.(*RemoveLocaleInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ListLocales_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLocalesInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ListLocales(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ListLocales_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ListLocales(ctx, req.(*ListLocalesInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_TranslateTerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TranslateTermInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).TranslateTerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_TranslateTerm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).TranslateTerm(ctx, req.(*TranslateTermInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ListTranslations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTranslationsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ListTranslations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ListTranslations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ListTranslations(ctx, req.(*ListTranslationsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_DeleteTranslation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTranslationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).DeleteTranslation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_DeleteTranslation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).DeleteTranslation(ctx, req.(*DeleteTranslationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_SuggestTranslation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestTranslationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).SuggestTranslation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_SuggestTranslation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).SuggestTranslation(ctx, req.(*SuggestTranslationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_UpdateTranslation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTranslationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).UpdateTranslation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_UpdateTranslation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).UpdateTranslation(ctx, req.(*UpdateTranslationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ApproveTranslation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveTranslationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ApproveTranslation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ApproveTranslation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ApproveTranslation(ctx, req.(*ApproveTranslationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_RejectTranslation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectTranslationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).RejectTranslation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_RejectTranslation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).RejectTranslation(ctx, req.(*RejectTranslationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ImportTranslations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportTranslationsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ImportTranslations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ImportTranslations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ImportTranslations(ctx, req.(*ImportTranslationsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ExportTranslations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportTranslationsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ExportTranslations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ExportTranslations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ExportTranslations(ctx, req.(*ExportTranslationsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalizationService_ListTranslationPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTranslationPairsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalizationServiceServer).ListTranslationPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalizationService_ListTranslationPairs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalizationServiceServer).ListTranslationPairs(ctx, req.(*ListTranslationPairsInput))
	}
	return interceptor(ctx, in, info, handler)
}

// LocalizationService_ServiceDesc is the grpc.ServiceDesc for LocalizationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocalizationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eolymp.l10n.LocalizationService",
	HandlerType: (*LocalizationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTerm",
			Handler:    _LocalizationService_CreateTerm_Handler,
		},
		{
			MethodName: "ListTerms",
			Handler:    _LocalizationService_ListTerms_Handler,
		},
		{
			MethodName: "UpdateTerm",
			Handler:    _LocalizationService_UpdateTerm_Handler,
		},
		{
			MethodName: "RestoreTerm",
			Handler:    _LocalizationService_RestoreTerm_Handler,
		},
		{
			MethodName: "DeprecateTerm",
			Handler:    _LocalizationService_DeprecateTerm_Handler,
		},
		{
			MethodName: "DeleteTerm",
			Handler:    _LocalizationService_DeleteTerm_Handler,
		},
		{
			MethodName: "DescribeTerm",
			Handler:    _LocalizationService_DescribeTerm_Handler,
		},
		{
			MethodName: "ImportTerms",
			Handler:    _LocalizationService_ImportTerms_Handler,
		},
		{
			MethodName: "AddLocale",
			Handler:    _LocalizationService_AddLocale_Handler,
		},
		{
			MethodName: "RemoveLocale",
			Handler:    _LocalizationService_RemoveLocale_Handler,
		},
		{
			MethodName: "ListLocales",
			Handler:    _LocalizationService_ListLocales_Handler,
		},
		{
			MethodName: "TranslateTerm",
			Handler:    _LocalizationService_TranslateTerm_Handler,
		},
		{
			MethodName: "ListTranslations",
			Handler:    _LocalizationService_ListTranslations_Handler,
		},
		{
			MethodName: "DeleteTranslation",
			Handler:    _LocalizationService_DeleteTranslation_Handler,
		},
		{
			MethodName: "SuggestTranslation",
			Handler:    _LocalizationService_SuggestTranslation_Handler,
		},
		{
			MethodName: "UpdateTranslation",
			Handler:    _LocalizationService_UpdateTranslation_Handler,
		},
		{
			MethodName: "ApproveTranslation",
			Handler:    _LocalizationService_ApproveTranslation_Handler,
		},
		{
			MethodName: "RejectTranslation",
			Handler:    _LocalizationService_RejectTranslation_Handler,
		},
		{
			MethodName: "ImportTranslations",
			Handler:    _LocalizationService_ImportTranslations_Handler,
		},
		{
			MethodName: "ExportTranslations",
			Handler:    _LocalizationService_ExportTranslations_Handler,
		},
		{
			MethodName: "ListTranslationPairs",
			Handler:    _LocalizationService_ListTranslationPairs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eolymp/l10n/localization_service.proto",
}
