// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package judge

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// JudgeClient is the client API for Judge service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JudgeClient interface {
	CreateContest(ctx context.Context, in *CreateContestInput, opts ...grpc.CallOption) (*CreateContestOutput, error)
	DeleteContest(ctx context.Context, in *DeleteContestInput, opts ...grpc.CallOption) (*DeleteContestOutput, error)
	UpdateContest(ctx context.Context, in *UpdateContestInput, opts ...grpc.CallOption) (*UpdateContestOutput, error)
	// LookupContest fetches basic (possibly incomplete) contest information. Right now this method is very similar to
	// DescribeContest, but looks up contest by domain name (key). Its purpose is different than DescribeContest, as
	// it attempts to "probe" contest rather than fetch complete information.
	//
	// This is first API call made by contest-ui just to check if domain name can be resolved into Contest ID.
	LookupContest(ctx context.Context, in *LookupContestInput, opts ...grpc.CallOption) (*LookupContestOutput, error)
	DescribeContest(ctx context.Context, in *DescribeContestInput, opts ...grpc.CallOption) (*DescribeContestOutput, error)
	ListContests(ctx context.Context, in *ListContestsInput, opts ...grpc.CallOption) (*ListContestsOutput, error)
	// Force-starts scheduled contest, this call also automatically changes starts_at to current time and adjusts
	// ends_at to match original date range of the contest.
	OpenContest(ctx context.Context, in *OpenContestInput, opts ...grpc.CallOption) (*OpenContestOutput, error)
	// Force-finishes open contest, this method automatically changes ends_at to current time.
	CloseContest(ctx context.Context, in *CloseContestInput, opts ...grpc.CallOption) (*CloseContestOutput, error)
	// ConfigureRegistrationForm allows to configure registration form for the contest.
	ConfigureRegistrationForm(ctx context.Context, in *ConfigureRegistrationFormInput, opts ...grpc.CallOption) (*ConfigureRegistrationFormOutput, error)
	// DescribeRegistrationForm allows fetch registration form for the contest.
	DescribeRegistrationForm(ctx context.Context, in *DescribeRegistrationFormInput, opts ...grpc.CallOption) (*DescribeRegistrationFormOutput, error)
	// ConfigureRuntime allows to configure which runtimes will be available during contest.
	// All available runtimes can be retrieved using `executor.ListRuntime` method.
	ConfigureRuntime(ctx context.Context, in *ConfigureRuntimeInput, opts ...grpc.CallOption) (*ConfigureRuntimeOutput, error)
	// DescribeRegistrationForm allows fetch registration form for the contest.
	DescribeRuntime(ctx context.Context, in *DescribeRuntimeInput, opts ...grpc.CallOption) (*DescribeRuntimeOutput, error)
	// SubmitRegistration allows participant to submit registration form data.
	SubmitRegistration(ctx context.Context, in *SubmitRegistrationInput, opts ...grpc.CallOption) (*SubmitRegistrationOutput, error)
	// DescribeRegistration allows participant to submit registration form data.
	DescribeRegistration(ctx context.Context, in *DescribeRegistrationInput, opts ...grpc.CallOption) (*DescribeRegistrationOutput, error)
	// ImportProblem from Atlas (problem catalog)
	ImportProblem(ctx context.Context, in *ImportProblemInput, opts ...grpc.CallOption) (*ImportProblemOutput, error)
	// SyncProblem with Atlas (problem catalog)
	SyncProblem(ctx context.Context, in *SyncProblemInput, opts ...grpc.CallOption) (*SyncProblemOutput, error)
	UpdateProblem(ctx context.Context, in *UpdateProblemInput, opts ...grpc.CallOption) (*UpdateProblemOutput, error)
	ListProblems(ctx context.Context, in *ListProblemsInput, opts ...grpc.CallOption) (*ListProblemsOutput, error)
	DescribeProblem(ctx context.Context, in *DescribeProblemInput, opts ...grpc.CallOption) (*DescribeProblemOutput, error)
	ListStatements(ctx context.Context, in *ListStatementsInput, opts ...grpc.CallOption) (*ListStatementsOutput, error)
	ListExamples(ctx context.Context, in *ListExamplesInput, opts ...grpc.CallOption) (*ListExamplesOutput, error)
	DeleteProblem(ctx context.Context, in *DeleteProblemInput, opts ...grpc.CallOption) (*DeleteProblemOutput, error)
	// RetestProblem resets existing submissions for the problem and triggers testing process again.
	RetestProblem(ctx context.Context, in *RetestProblemInput, opts ...grpc.CallOption) (*RetestProblemOutput, error)
	AddParticipant(ctx context.Context, in *AddParticipantInput, opts ...grpc.CallOption) (*AddParticipantOutput, error)
	EnableParticipant(ctx context.Context, in *EnableParticipantInput, opts ...grpc.CallOption) (*EnableParticipantOutput, error)
	DisableParticipant(ctx context.Context, in *DisableParticipantInput, opts ...grpc.CallOption) (*DisableParticipantOutput, error)
	// Verify if passcode is required for the contest and if authenticated token has entered the passcode.
	VerifyPasscode(ctx context.Context, in *VerifyPasscodeInput, opts ...grpc.CallOption) (*VerifyPasscodeOutput, error)
	// Enter passcode marks current session as one authenticated by passcode.
	EnterPasscode(ctx context.Context, in *EnterPasscodeInput, opts ...grpc.CallOption) (*EnterPasscodeOutput, error)
	// Set a new passcode to the participant, if passcode was not set it will be now required
	ResetPasscode(ctx context.Context, in *ResetPasscodeInput, opts ...grpc.CallOption) (*ResetPasscodeOutput, error)
	// Remove passcode from participant and allow her to enter contest without passcode.
	RemovePasscode(ctx context.Context, in *RemovePasscodeInput, opts ...grpc.CallOption) (*RemovePasscodeOutput, error)
	RemoveParticipant(ctx context.Context, in *RemoveParticipantInput, opts ...grpc.CallOption) (*RemoveParticipantOutput, error)
	ListParticipants(ctx context.Context, in *ListParticipantsInput, opts ...grpc.CallOption) (*ListParticipantsOutput, error)
	DescribeParticipant(ctx context.Context, in *DescribeParticipantInput, opts ...grpc.CallOption) (*DescribeParticipantOutput, error)
	// IntrospectParticipant allows to fetch participant data for a currently authorized user.
	IntrospectParticipant(ctx context.Context, in *IntrospectParticipantInput, opts ...grpc.CallOption) (*IntrospectParticipantOutput, error)
	// Allows a participant (currently authorized user) to join (add himself to) a public contest.
	JoinContest(ctx context.Context, in *JoinContestInput, opts ...grpc.CallOption) (*JoinContestOutput, error)
	// Allows a participant (currently authorized user) to start participating in the contest, see problems and submit solutions.
	StartContest(ctx context.Context, in *StartContestInput, opts ...grpc.CallOption) (*StartContestOutput, error)
	// Creates submissions and triggers test process.
	CreateSubmission(ctx context.Context, in *CreateSubmissionInput, opts ...grpc.CallOption) (*CreateSubmissionOutput, error)
	ListSubmissions(ctx context.Context, in *ListSubmissionsInput, opts ...grpc.CallOption) (*ListSubmissionsOutput, error)
	DescribeSubmission(ctx context.Context, in *DescribeSubmissionInput, opts ...grpc.CallOption) (*DescribeSubmissionOutput, error)
	// Resets submission results and triggers testing process.
	RetestSubmission(ctx context.Context, in *RetestSubmissionInput, opts ...grpc.CallOption) (*RetestSubmissionOutput, error)
	// Create a new ticket
	CreateTicket(ctx context.Context, in *CreateTicketInput, opts ...grpc.CallOption) (*CreateTicketOutput, error)
	// Mark ticket as Closed
	CloseTicket(ctx context.Context, in *CloseTicketInput, opts ...grpc.CallOption) (*CloseTicketOutput, error)
	// Mark ticket as Open
	OpenTicket(ctx context.Context, in *OpenTicketInput, opts ...grpc.CallOption) (*OpenTicketOutput, error)
	// ReadTicket marks ticket as read by participant (sets is_read flag to true).
	ReadTicket(ctx context.Context, in *ReadTicketInput, opts ...grpc.CallOption) (*ReadTicketOutput, error)
	DeleteTicket(ctx context.Context, in *DeleteTicketInput, opts ...grpc.CallOption) (*DeleteTicketOutput, error)
	DescribeTicket(ctx context.Context, in *DescribeTicketInput, opts ...grpc.CallOption) (*DescribeTicketOutput, error)
	// ListTickets fetches tickets matching criteria in the input parameter.
	ListTickets(ctx context.Context, in *ListTicketsInput, opts ...grpc.CallOption) (*ListTicketsOutput, error)
	// ReplyTicket allows to add reply to a ticket. If reply is added by participant it sets is_read and needs_reply to
	// true, otherwise, if reply added by contest administrator, this method sets these flags to false.
	ReplyTicket(ctx context.Context, in *ReplyTicketInput, opts ...grpc.CallOption) (*ReplyTicketOutput, error)
	// ListReplies fetches replies for a particular ticket.
	ListReplies(ctx context.Context, in *ListRepliesInput, opts ...grpc.CallOption) (*ListRepliesOutput, error)
	// DeleteReply allows author to delete his own reply.
	DeleteReply(ctx context.Context, in *DeleteReplyInput, opts ...grpc.CallOption) (*DeleteReplyOutput, error)
	// UpdateReply allows author to update his own reply.
	UpdateReply(ctx context.Context, in *UpdateReplyInput, opts ...grpc.CallOption) (*UpdateReplyOutput, error)
	// Create announcement for a contest
	CreateAnnouncement(ctx context.Context, in *CreateAnnouncementInput, opts ...grpc.CallOption) (*CreateAnnouncementOutput, error)
	// Update existing announcement in a contest
	UpdateAnnouncement(ctx context.Context, in *UpdateAnnouncementInput, opts ...grpc.CallOption) (*UpdateAnnouncementOutput, error)
	// Delete announcement
	DeleteAnnouncement(ctx context.Context, in *DeleteAnnouncementInput, opts ...grpc.CallOption) (*DeleteAnnouncementOutput, error)
	// Mark announcement as read by authenticated participant
	ReadAnnouncement(ctx context.Context, in *ReadAnnouncementInput, opts ...grpc.CallOption) (*ReadAnnouncementOutput, error)
	// Describe announcement
	DescribeAnnouncement(ctx context.Context, in *DescribeAnnouncementInput, opts ...grpc.CallOption) (*DescribeAnnouncementOutput, error)
	// Describe announcement status
	DescribeAnnouncementStatus(ctx context.Context, in *DescribeAnnouncementStatusInput, opts ...grpc.CallOption) (*DescribeAnnouncementStatusOutput, error)
	// List announcements of a contest
	ListAnnouncements(ctx context.Context, in *ListAnnouncementsInput, opts ...grpc.CallOption) (*ListAnnouncementsOutput, error)
	// Return code template for problem
	DescribeCodeTemplate(ctx context.Context, in *DescribeCodeTemplateInput, opts ...grpc.CallOption) (*DescribeCodeTemplateOutput, error)
}

type judgeClient struct {
	cc grpc.ClientConnInterface
}

func NewJudgeClient(cc grpc.ClientConnInterface) JudgeClient {
	return &judgeClient{cc}
}

func (c *judgeClient) CreateContest(ctx context.Context, in *CreateContestInput, opts ...grpc.CallOption) (*CreateContestOutput, error) {
	out := new(CreateContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/CreateContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteContest(ctx context.Context, in *DeleteContestInput, opts ...grpc.CallOption) (*DeleteContestOutput, error) {
	out := new(DeleteContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DeleteContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateContest(ctx context.Context, in *UpdateContestInput, opts ...grpc.CallOption) (*UpdateContestOutput, error) {
	out := new(UpdateContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/UpdateContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) LookupContest(ctx context.Context, in *LookupContestInput, opts ...grpc.CallOption) (*LookupContestOutput, error) {
	out := new(LookupContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/LookupContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeContest(ctx context.Context, in *DescribeContestInput, opts ...grpc.CallOption) (*DescribeContestOutput, error) {
	out := new(DescribeContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListContests(ctx context.Context, in *ListContestsInput, opts ...grpc.CallOption) (*ListContestsOutput, error) {
	out := new(ListContestsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListContests", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) OpenContest(ctx context.Context, in *OpenContestInput, opts ...grpc.CallOption) (*OpenContestOutput, error) {
	out := new(OpenContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/OpenContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CloseContest(ctx context.Context, in *CloseContestInput, opts ...grpc.CallOption) (*CloseContestOutput, error) {
	out := new(CloseContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/CloseContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ConfigureRegistrationForm(ctx context.Context, in *ConfigureRegistrationFormInput, opts ...grpc.CallOption) (*ConfigureRegistrationFormOutput, error) {
	out := new(ConfigureRegistrationFormOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ConfigureRegistrationForm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeRegistrationForm(ctx context.Context, in *DescribeRegistrationFormInput, opts ...grpc.CallOption) (*DescribeRegistrationFormOutput, error) {
	out := new(DescribeRegistrationFormOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeRegistrationForm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ConfigureRuntime(ctx context.Context, in *ConfigureRuntimeInput, opts ...grpc.CallOption) (*ConfigureRuntimeOutput, error) {
	out := new(ConfigureRuntimeOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ConfigureRuntime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeRuntime(ctx context.Context, in *DescribeRuntimeInput, opts ...grpc.CallOption) (*DescribeRuntimeOutput, error) {
	out := new(DescribeRuntimeOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeRuntime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) SubmitRegistration(ctx context.Context, in *SubmitRegistrationInput, opts ...grpc.CallOption) (*SubmitRegistrationOutput, error) {
	out := new(SubmitRegistrationOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/SubmitRegistration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeRegistration(ctx context.Context, in *DescribeRegistrationInput, opts ...grpc.CallOption) (*DescribeRegistrationOutput, error) {
	out := new(DescribeRegistrationOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeRegistration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ImportProblem(ctx context.Context, in *ImportProblemInput, opts ...grpc.CallOption) (*ImportProblemOutput, error) {
	out := new(ImportProblemOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ImportProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) SyncProblem(ctx context.Context, in *SyncProblemInput, opts ...grpc.CallOption) (*SyncProblemOutput, error) {
	out := new(SyncProblemOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/SyncProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateProblem(ctx context.Context, in *UpdateProblemInput, opts ...grpc.CallOption) (*UpdateProblemOutput, error) {
	out := new(UpdateProblemOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/UpdateProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListProblems(ctx context.Context, in *ListProblemsInput, opts ...grpc.CallOption) (*ListProblemsOutput, error) {
	out := new(ListProblemsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListProblems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeProblem(ctx context.Context, in *DescribeProblemInput, opts ...grpc.CallOption) (*DescribeProblemOutput, error) {
	out := new(DescribeProblemOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListStatements(ctx context.Context, in *ListStatementsInput, opts ...grpc.CallOption) (*ListStatementsOutput, error) {
	out := new(ListStatementsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListStatements", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListExamples(ctx context.Context, in *ListExamplesInput, opts ...grpc.CallOption) (*ListExamplesOutput, error) {
	out := new(ListExamplesOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListExamples", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteProblem(ctx context.Context, in *DeleteProblemInput, opts ...grpc.CallOption) (*DeleteProblemOutput, error) {
	out := new(DeleteProblemOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DeleteProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RetestProblem(ctx context.Context, in *RetestProblemInput, opts ...grpc.CallOption) (*RetestProblemOutput, error) {
	out := new(RetestProblemOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/RetestProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) AddParticipant(ctx context.Context, in *AddParticipantInput, opts ...grpc.CallOption) (*AddParticipantOutput, error) {
	out := new(AddParticipantOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/AddParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) EnableParticipant(ctx context.Context, in *EnableParticipantInput, opts ...grpc.CallOption) (*EnableParticipantOutput, error) {
	out := new(EnableParticipantOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/EnableParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DisableParticipant(ctx context.Context, in *DisableParticipantInput, opts ...grpc.CallOption) (*DisableParticipantOutput, error) {
	out := new(DisableParticipantOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DisableParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) VerifyPasscode(ctx context.Context, in *VerifyPasscodeInput, opts ...grpc.CallOption) (*VerifyPasscodeOutput, error) {
	out := new(VerifyPasscodeOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/VerifyPasscode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) EnterPasscode(ctx context.Context, in *EnterPasscodeInput, opts ...grpc.CallOption) (*EnterPasscodeOutput, error) {
	out := new(EnterPasscodeOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/EnterPasscode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ResetPasscode(ctx context.Context, in *ResetPasscodeInput, opts ...grpc.CallOption) (*ResetPasscodeOutput, error) {
	out := new(ResetPasscodeOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ResetPasscode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RemovePasscode(ctx context.Context, in *RemovePasscodeInput, opts ...grpc.CallOption) (*RemovePasscodeOutput, error) {
	out := new(RemovePasscodeOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/RemovePasscode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RemoveParticipant(ctx context.Context, in *RemoveParticipantInput, opts ...grpc.CallOption) (*RemoveParticipantOutput, error) {
	out := new(RemoveParticipantOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/RemoveParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListParticipants(ctx context.Context, in *ListParticipantsInput, opts ...grpc.CallOption) (*ListParticipantsOutput, error) {
	out := new(ListParticipantsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListParticipants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeParticipant(ctx context.Context, in *DescribeParticipantInput, opts ...grpc.CallOption) (*DescribeParticipantOutput, error) {
	out := new(DescribeParticipantOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) IntrospectParticipant(ctx context.Context, in *IntrospectParticipantInput, opts ...grpc.CallOption) (*IntrospectParticipantOutput, error) {
	out := new(IntrospectParticipantOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/IntrospectParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) JoinContest(ctx context.Context, in *JoinContestInput, opts ...grpc.CallOption) (*JoinContestOutput, error) {
	out := new(JoinContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/JoinContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) StartContest(ctx context.Context, in *StartContestInput, opts ...grpc.CallOption) (*StartContestOutput, error) {
	out := new(StartContestOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/StartContest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CreateSubmission(ctx context.Context, in *CreateSubmissionInput, opts ...grpc.CallOption) (*CreateSubmissionOutput, error) {
	out := new(CreateSubmissionOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/CreateSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListSubmissions(ctx context.Context, in *ListSubmissionsInput, opts ...grpc.CallOption) (*ListSubmissionsOutput, error) {
	out := new(ListSubmissionsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListSubmissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeSubmission(ctx context.Context, in *DescribeSubmissionInput, opts ...grpc.CallOption) (*DescribeSubmissionOutput, error) {
	out := new(DescribeSubmissionOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RetestSubmission(ctx context.Context, in *RetestSubmissionInput, opts ...grpc.CallOption) (*RetestSubmissionOutput, error) {
	out := new(RetestSubmissionOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/RetestSubmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CreateTicket(ctx context.Context, in *CreateTicketInput, opts ...grpc.CallOption) (*CreateTicketOutput, error) {
	out := new(CreateTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/CreateTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CloseTicket(ctx context.Context, in *CloseTicketInput, opts ...grpc.CallOption) (*CloseTicketOutput, error) {
	out := new(CloseTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/CloseTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) OpenTicket(ctx context.Context, in *OpenTicketInput, opts ...grpc.CallOption) (*OpenTicketOutput, error) {
	out := new(OpenTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/OpenTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ReadTicket(ctx context.Context, in *ReadTicketInput, opts ...grpc.CallOption) (*ReadTicketOutput, error) {
	out := new(ReadTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ReadTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteTicket(ctx context.Context, in *DeleteTicketInput, opts ...grpc.CallOption) (*DeleteTicketOutput, error) {
	out := new(DeleteTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DeleteTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeTicket(ctx context.Context, in *DescribeTicketInput, opts ...grpc.CallOption) (*DescribeTicketOutput, error) {
	out := new(DescribeTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListTickets(ctx context.Context, in *ListTicketsInput, opts ...grpc.CallOption) (*ListTicketsOutput, error) {
	out := new(ListTicketsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListTickets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ReplyTicket(ctx context.Context, in *ReplyTicketInput, opts ...grpc.CallOption) (*ReplyTicketOutput, error) {
	out := new(ReplyTicketOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ReplyTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListReplies(ctx context.Context, in *ListRepliesInput, opts ...grpc.CallOption) (*ListRepliesOutput, error) {
	out := new(ListRepliesOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListReplies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteReply(ctx context.Context, in *DeleteReplyInput, opts ...grpc.CallOption) (*DeleteReplyOutput, error) {
	out := new(DeleteReplyOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DeleteReply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateReply(ctx context.Context, in *UpdateReplyInput, opts ...grpc.CallOption) (*UpdateReplyOutput, error) {
	out := new(UpdateReplyOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/UpdateReply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CreateAnnouncement(ctx context.Context, in *CreateAnnouncementInput, opts ...grpc.CallOption) (*CreateAnnouncementOutput, error) {
	out := new(CreateAnnouncementOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/CreateAnnouncement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateAnnouncement(ctx context.Context, in *UpdateAnnouncementInput, opts ...grpc.CallOption) (*UpdateAnnouncementOutput, error) {
	out := new(UpdateAnnouncementOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/UpdateAnnouncement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteAnnouncement(ctx context.Context, in *DeleteAnnouncementInput, opts ...grpc.CallOption) (*DeleteAnnouncementOutput, error) {
	out := new(DeleteAnnouncementOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DeleteAnnouncement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ReadAnnouncement(ctx context.Context, in *ReadAnnouncementInput, opts ...grpc.CallOption) (*ReadAnnouncementOutput, error) {
	out := new(ReadAnnouncementOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ReadAnnouncement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeAnnouncement(ctx context.Context, in *DescribeAnnouncementInput, opts ...grpc.CallOption) (*DescribeAnnouncementOutput, error) {
	out := new(DescribeAnnouncementOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeAnnouncement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeAnnouncementStatus(ctx context.Context, in *DescribeAnnouncementStatusInput, opts ...grpc.CallOption) (*DescribeAnnouncementStatusOutput, error) {
	out := new(DescribeAnnouncementStatusOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeAnnouncementStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListAnnouncements(ctx context.Context, in *ListAnnouncementsInput, opts ...grpc.CallOption) (*ListAnnouncementsOutput, error) {
	out := new(ListAnnouncementsOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/ListAnnouncements", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeCodeTemplate(ctx context.Context, in *DescribeCodeTemplateInput, opts ...grpc.CallOption) (*DescribeCodeTemplateOutput, error) {
	out := new(DescribeCodeTemplateOutput)
	err := c.cc.Invoke(ctx, "/eolymp.judge.Judge/DescribeCodeTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JudgeServer is the server API for Judge service.
// All implementations must embed UnimplementedJudgeServer
// for forward compatibility
type JudgeServer interface {
	CreateContest(context.Context, *CreateContestInput) (*CreateContestOutput, error)
	DeleteContest(context.Context, *DeleteContestInput) (*DeleteContestOutput, error)
	UpdateContest(context.Context, *UpdateContestInput) (*UpdateContestOutput, error)
	// LookupContest fetches basic (possibly incomplete) contest information. Right now this method is very similar to
	// DescribeContest, but looks up contest by domain name (key). Its purpose is different than DescribeContest, as
	// it attempts to "probe" contest rather than fetch complete information.
	//
	// This is first API call made by contest-ui just to check if domain name can be resolved into Contest ID.
	LookupContest(context.Context, *LookupContestInput) (*LookupContestOutput, error)
	DescribeContest(context.Context, *DescribeContestInput) (*DescribeContestOutput, error)
	ListContests(context.Context, *ListContestsInput) (*ListContestsOutput, error)
	// Force-starts scheduled contest, this call also automatically changes starts_at to current time and adjusts
	// ends_at to match original date range of the contest.
	OpenContest(context.Context, *OpenContestInput) (*OpenContestOutput, error)
	// Force-finishes open contest, this method automatically changes ends_at to current time.
	CloseContest(context.Context, *CloseContestInput) (*CloseContestOutput, error)
	// ConfigureRegistrationForm allows to configure registration form for the contest.
	ConfigureRegistrationForm(context.Context, *ConfigureRegistrationFormInput) (*ConfigureRegistrationFormOutput, error)
	// DescribeRegistrationForm allows fetch registration form for the contest.
	DescribeRegistrationForm(context.Context, *DescribeRegistrationFormInput) (*DescribeRegistrationFormOutput, error)
	// ConfigureRuntime allows to configure which runtimes will be available during contest.
	// All available runtimes can be retrieved using `executor.ListRuntime` method.
	ConfigureRuntime(context.Context, *ConfigureRuntimeInput) (*ConfigureRuntimeOutput, error)
	// DescribeRegistrationForm allows fetch registration form for the contest.
	DescribeRuntime(context.Context, *DescribeRuntimeInput) (*DescribeRuntimeOutput, error)
	// SubmitRegistration allows participant to submit registration form data.
	SubmitRegistration(context.Context, *SubmitRegistrationInput) (*SubmitRegistrationOutput, error)
	// DescribeRegistration allows participant to submit registration form data.
	DescribeRegistration(context.Context, *DescribeRegistrationInput) (*DescribeRegistrationOutput, error)
	// ImportProblem from Atlas (problem catalog)
	ImportProblem(context.Context, *ImportProblemInput) (*ImportProblemOutput, error)
	// SyncProblem with Atlas (problem catalog)
	SyncProblem(context.Context, *SyncProblemInput) (*SyncProblemOutput, error)
	UpdateProblem(context.Context, *UpdateProblemInput) (*UpdateProblemOutput, error)
	ListProblems(context.Context, *ListProblemsInput) (*ListProblemsOutput, error)
	DescribeProblem(context.Context, *DescribeProblemInput) (*DescribeProblemOutput, error)
	ListStatements(context.Context, *ListStatementsInput) (*ListStatementsOutput, error)
	ListExamples(context.Context, *ListExamplesInput) (*ListExamplesOutput, error)
	DeleteProblem(context.Context, *DeleteProblemInput) (*DeleteProblemOutput, error)
	// RetestProblem resets existing submissions for the problem and triggers testing process again.
	RetestProblem(context.Context, *RetestProblemInput) (*RetestProblemOutput, error)
	AddParticipant(context.Context, *AddParticipantInput) (*AddParticipantOutput, error)
	EnableParticipant(context.Context, *EnableParticipantInput) (*EnableParticipantOutput, error)
	DisableParticipant(context.Context, *DisableParticipantInput) (*DisableParticipantOutput, error)
	// Verify if passcode is required for the contest and if authenticated token has entered the passcode.
	VerifyPasscode(context.Context, *VerifyPasscodeInput) (*VerifyPasscodeOutput, error)
	// Enter passcode marks current session as one authenticated by passcode.
	EnterPasscode(context.Context, *EnterPasscodeInput) (*EnterPasscodeOutput, error)
	// Set a new passcode to the participant, if passcode was not set it will be now required
	ResetPasscode(context.Context, *ResetPasscodeInput) (*ResetPasscodeOutput, error)
	// Remove passcode from participant and allow her to enter contest without passcode.
	RemovePasscode(context.Context, *RemovePasscodeInput) (*RemovePasscodeOutput, error)
	RemoveParticipant(context.Context, *RemoveParticipantInput) (*RemoveParticipantOutput, error)
	ListParticipants(context.Context, *ListParticipantsInput) (*ListParticipantsOutput, error)
	DescribeParticipant(context.Context, *DescribeParticipantInput) (*DescribeParticipantOutput, error)
	// IntrospectParticipant allows to fetch participant data for a currently authorized user.
	IntrospectParticipant(context.Context, *IntrospectParticipantInput) (*IntrospectParticipantOutput, error)
	// Allows a participant (currently authorized user) to join (add himself to) a public contest.
	JoinContest(context.Context, *JoinContestInput) (*JoinContestOutput, error)
	// Allows a participant (currently authorized user) to start participating in the contest, see problems and submit solutions.
	StartContest(context.Context, *StartContestInput) (*StartContestOutput, error)
	// Creates submissions and triggers test process.
	CreateSubmission(context.Context, *CreateSubmissionInput) (*CreateSubmissionOutput, error)
	ListSubmissions(context.Context, *ListSubmissionsInput) (*ListSubmissionsOutput, error)
	DescribeSubmission(context.Context, *DescribeSubmissionInput) (*DescribeSubmissionOutput, error)
	// Resets submission results and triggers testing process.
	RetestSubmission(context.Context, *RetestSubmissionInput) (*RetestSubmissionOutput, error)
	// Create a new ticket
	CreateTicket(context.Context, *CreateTicketInput) (*CreateTicketOutput, error)
	// Mark ticket as Closed
	CloseTicket(context.Context, *CloseTicketInput) (*CloseTicketOutput, error)
	// Mark ticket as Open
	OpenTicket(context.Context, *OpenTicketInput) (*OpenTicketOutput, error)
	// ReadTicket marks ticket as read by participant (sets is_read flag to true).
	ReadTicket(context.Context, *ReadTicketInput) (*ReadTicketOutput, error)
	DeleteTicket(context.Context, *DeleteTicketInput) (*DeleteTicketOutput, error)
	DescribeTicket(context.Context, *DescribeTicketInput) (*DescribeTicketOutput, error)
	// ListTickets fetches tickets matching criteria in the input parameter.
	ListTickets(context.Context, *ListTicketsInput) (*ListTicketsOutput, error)
	// ReplyTicket allows to add reply to a ticket. If reply is added by participant it sets is_read and needs_reply to
	// true, otherwise, if reply added by contest administrator, this method sets these flags to false.
	ReplyTicket(context.Context, *ReplyTicketInput) (*ReplyTicketOutput, error)
	// ListReplies fetches replies for a particular ticket.
	ListReplies(context.Context, *ListRepliesInput) (*ListRepliesOutput, error)
	// DeleteReply allows author to delete his own reply.
	DeleteReply(context.Context, *DeleteReplyInput) (*DeleteReplyOutput, error)
	// UpdateReply allows author to update his own reply.
	UpdateReply(context.Context, *UpdateReplyInput) (*UpdateReplyOutput, error)
	// Create announcement for a contest
	CreateAnnouncement(context.Context, *CreateAnnouncementInput) (*CreateAnnouncementOutput, error)
	// Update existing announcement in a contest
	UpdateAnnouncement(context.Context, *UpdateAnnouncementInput) (*UpdateAnnouncementOutput, error)
	// Delete announcement
	DeleteAnnouncement(context.Context, *DeleteAnnouncementInput) (*DeleteAnnouncementOutput, error)
	// Mark announcement as read by authenticated participant
	ReadAnnouncement(context.Context, *ReadAnnouncementInput) (*ReadAnnouncementOutput, error)
	// Describe announcement
	DescribeAnnouncement(context.Context, *DescribeAnnouncementInput) (*DescribeAnnouncementOutput, error)
	// Describe announcement status
	DescribeAnnouncementStatus(context.Context, *DescribeAnnouncementStatusInput) (*DescribeAnnouncementStatusOutput, error)
	// List announcements of a contest
	ListAnnouncements(context.Context, *ListAnnouncementsInput) (*ListAnnouncementsOutput, error)
	// Return code template for problem
	DescribeCodeTemplate(context.Context, *DescribeCodeTemplateInput) (*DescribeCodeTemplateOutput, error)
	mustEmbedUnimplementedJudgeServer()
}

// UnimplementedJudgeServer must be embedded to have forward compatible implementations.
type UnimplementedJudgeServer struct {
}

func (UnimplementedJudgeServer) CreateContest(context.Context, *CreateContestInput) (*CreateContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContest not implemented")
}
func (UnimplementedJudgeServer) DeleteContest(context.Context, *DeleteContestInput) (*DeleteContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteContest not implemented")
}
func (UnimplementedJudgeServer) UpdateContest(context.Context, *UpdateContestInput) (*UpdateContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateContest not implemented")
}
func (UnimplementedJudgeServer) LookupContest(context.Context, *LookupContestInput) (*LookupContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupContest not implemented")
}
func (UnimplementedJudgeServer) DescribeContest(context.Context, *DescribeContestInput) (*DescribeContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeContest not implemented")
}
func (UnimplementedJudgeServer) ListContests(context.Context, *ListContestsInput) (*ListContestsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContests not implemented")
}
func (UnimplementedJudgeServer) OpenContest(context.Context, *OpenContestInput) (*OpenContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenContest not implemented")
}
func (UnimplementedJudgeServer) CloseContest(context.Context, *CloseContestInput) (*CloseContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseContest not implemented")
}
func (UnimplementedJudgeServer) ConfigureRegistrationForm(context.Context, *ConfigureRegistrationFormInput) (*ConfigureRegistrationFormOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureRegistrationForm not implemented")
}
func (UnimplementedJudgeServer) DescribeRegistrationForm(context.Context, *DescribeRegistrationFormInput) (*DescribeRegistrationFormOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeRegistrationForm not implemented")
}
func (UnimplementedJudgeServer) ConfigureRuntime(context.Context, *ConfigureRuntimeInput) (*ConfigureRuntimeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureRuntime not implemented")
}
func (UnimplementedJudgeServer) DescribeRuntime(context.Context, *DescribeRuntimeInput) (*DescribeRuntimeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeRuntime not implemented")
}
func (UnimplementedJudgeServer) SubmitRegistration(context.Context, *SubmitRegistrationInput) (*SubmitRegistrationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRegistration not implemented")
}
func (UnimplementedJudgeServer) DescribeRegistration(context.Context, *DescribeRegistrationInput) (*DescribeRegistrationOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeRegistration not implemented")
}
func (UnimplementedJudgeServer) ImportProblem(context.Context, *ImportProblemInput) (*ImportProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportProblem not implemented")
}
func (UnimplementedJudgeServer) SyncProblem(context.Context, *SyncProblemInput) (*SyncProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncProblem not implemented")
}
func (UnimplementedJudgeServer) UpdateProblem(context.Context, *UpdateProblemInput) (*UpdateProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProblem not implemented")
}
func (UnimplementedJudgeServer) ListProblems(context.Context, *ListProblemsInput) (*ListProblemsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProblems not implemented")
}
func (UnimplementedJudgeServer) DescribeProblem(context.Context, *DescribeProblemInput) (*DescribeProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeProblem not implemented")
}
func (UnimplementedJudgeServer) ListStatements(context.Context, *ListStatementsInput) (*ListStatementsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStatements not implemented")
}
func (UnimplementedJudgeServer) ListExamples(context.Context, *ListExamplesInput) (*ListExamplesOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExamples not implemented")
}
func (UnimplementedJudgeServer) DeleteProblem(context.Context, *DeleteProblemInput) (*DeleteProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProblem not implemented")
}
func (UnimplementedJudgeServer) RetestProblem(context.Context, *RetestProblemInput) (*RetestProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetestProblem not implemented")
}
func (UnimplementedJudgeServer) AddParticipant(context.Context, *AddParticipantInput) (*AddParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddParticipant not implemented")
}
func (UnimplementedJudgeServer) EnableParticipant(context.Context, *EnableParticipantInput) (*EnableParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableParticipant not implemented")
}
func (UnimplementedJudgeServer) DisableParticipant(context.Context, *DisableParticipantInput) (*DisableParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableParticipant not implemented")
}
func (UnimplementedJudgeServer) VerifyPasscode(context.Context, *VerifyPasscodeInput) (*VerifyPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyPasscode not implemented")
}
func (UnimplementedJudgeServer) EnterPasscode(context.Context, *EnterPasscodeInput) (*EnterPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnterPasscode not implemented")
}
func (UnimplementedJudgeServer) ResetPasscode(context.Context, *ResetPasscodeInput) (*ResetPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPasscode not implemented")
}
func (UnimplementedJudgeServer) RemovePasscode(context.Context, *RemovePasscodeInput) (*RemovePasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePasscode not implemented")
}
func (UnimplementedJudgeServer) RemoveParticipant(context.Context, *RemoveParticipantInput) (*RemoveParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveParticipant not implemented")
}
func (UnimplementedJudgeServer) ListParticipants(context.Context, *ListParticipantsInput) (*ListParticipantsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListParticipants not implemented")
}
func (UnimplementedJudgeServer) DescribeParticipant(context.Context, *DescribeParticipantInput) (*DescribeParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeParticipant not implemented")
}
func (UnimplementedJudgeServer) IntrospectParticipant(context.Context, *IntrospectParticipantInput) (*IntrospectParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntrospectParticipant not implemented")
}
func (UnimplementedJudgeServer) JoinContest(context.Context, *JoinContestInput) (*JoinContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinContest not implemented")
}
func (UnimplementedJudgeServer) StartContest(context.Context, *StartContestInput) (*StartContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartContest not implemented")
}
func (UnimplementedJudgeServer) CreateSubmission(context.Context, *CreateSubmissionInput) (*CreateSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubmission not implemented")
}
func (UnimplementedJudgeServer) ListSubmissions(context.Context, *ListSubmissionsInput) (*ListSubmissionsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubmissions not implemented")
}
func (UnimplementedJudgeServer) DescribeSubmission(context.Context, *DescribeSubmissionInput) (*DescribeSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeSubmission not implemented")
}
func (UnimplementedJudgeServer) RetestSubmission(context.Context, *RetestSubmissionInput) (*RetestSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetestSubmission not implemented")
}
func (UnimplementedJudgeServer) CreateTicket(context.Context, *CreateTicketInput) (*CreateTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTicket not implemented")
}
func (UnimplementedJudgeServer) CloseTicket(context.Context, *CloseTicketInput) (*CloseTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseTicket not implemented")
}
func (UnimplementedJudgeServer) OpenTicket(context.Context, *OpenTicketInput) (*OpenTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenTicket not implemented")
}
func (UnimplementedJudgeServer) ReadTicket(context.Context, *ReadTicketInput) (*ReadTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadTicket not implemented")
}
func (UnimplementedJudgeServer) DeleteTicket(context.Context, *DeleteTicketInput) (*DeleteTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTicket not implemented")
}
func (UnimplementedJudgeServer) DescribeTicket(context.Context, *DescribeTicketInput) (*DescribeTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTicket not implemented")
}
func (UnimplementedJudgeServer) ListTickets(context.Context, *ListTicketsInput) (*ListTicketsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTickets not implemented")
}
func (UnimplementedJudgeServer) ReplyTicket(context.Context, *ReplyTicketInput) (*ReplyTicketOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplyTicket not implemented")
}
func (UnimplementedJudgeServer) ListReplies(context.Context, *ListRepliesInput) (*ListRepliesOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReplies not implemented")
}
func (UnimplementedJudgeServer) DeleteReply(context.Context, *DeleteReplyInput) (*DeleteReplyOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReply not implemented")
}
func (UnimplementedJudgeServer) UpdateReply(context.Context, *UpdateReplyInput) (*UpdateReplyOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReply not implemented")
}
func (UnimplementedJudgeServer) CreateAnnouncement(context.Context, *CreateAnnouncementInput) (*CreateAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAnnouncement not implemented")
}
func (UnimplementedJudgeServer) UpdateAnnouncement(context.Context, *UpdateAnnouncementInput) (*UpdateAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAnnouncement not implemented")
}
func (UnimplementedJudgeServer) DeleteAnnouncement(context.Context, *DeleteAnnouncementInput) (*DeleteAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAnnouncement not implemented")
}
func (UnimplementedJudgeServer) ReadAnnouncement(context.Context, *ReadAnnouncementInput) (*ReadAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAnnouncement not implemented")
}
func (UnimplementedJudgeServer) DescribeAnnouncement(context.Context, *DescribeAnnouncementInput) (*DescribeAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeAnnouncement not implemented")
}
func (UnimplementedJudgeServer) DescribeAnnouncementStatus(context.Context, *DescribeAnnouncementStatusInput) (*DescribeAnnouncementStatusOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeAnnouncementStatus not implemented")
}
func (UnimplementedJudgeServer) ListAnnouncements(context.Context, *ListAnnouncementsInput) (*ListAnnouncementsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAnnouncements not implemented")
}
func (UnimplementedJudgeServer) DescribeCodeTemplate(context.Context, *DescribeCodeTemplateInput) (*DescribeCodeTemplateOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeCodeTemplate not implemented")
}
func (UnimplementedJudgeServer) mustEmbedUnimplementedJudgeServer() {}

// UnsafeJudgeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JudgeServer will
// result in compilation errors.
type UnsafeJudgeServer interface {
	mustEmbedUnimplementedJudgeServer()
}

func RegisterJudgeServer(s grpc.ServiceRegistrar, srv JudgeServer) {
	s.RegisterService(&Judge_ServiceDesc, srv)
}

func _Judge_CreateContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/CreateContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateContest(ctx, req.(*CreateContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DeleteContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteContest(ctx, req.(*DeleteContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/UpdateContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateContest(ctx, req.(*UpdateContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_LookupContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).LookupContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/LookupContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).LookupContest(ctx, req.(*LookupContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeContest(ctx, req.(*DescribeContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListContests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContestsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListContests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListContests",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListContests(ctx, req.(*ListContestsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_OpenContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).OpenContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/OpenContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).OpenContest(ctx, req.(*OpenContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CloseContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CloseContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/CloseContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CloseContest(ctx, req.(*CloseContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ConfigureRegistrationForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureRegistrationFormInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ConfigureRegistrationForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ConfigureRegistrationForm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ConfigureRegistrationForm(ctx, req.(*ConfigureRegistrationFormInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeRegistrationForm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRegistrationFormInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeRegistrationForm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeRegistrationForm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeRegistrationForm(ctx, req.(*DescribeRegistrationFormInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ConfigureRuntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureRuntimeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ConfigureRuntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ConfigureRuntime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ConfigureRuntime(ctx, req.(*ConfigureRuntimeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeRuntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRuntimeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeRuntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeRuntime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeRuntime(ctx, req.(*DescribeRuntimeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_SubmitRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitRegistrationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).SubmitRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/SubmitRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).SubmitRegistration(ctx, req.(*SubmitRegistrationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRegistrationInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeRegistration(ctx, req.(*DescribeRegistrationInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ImportProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ImportProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ImportProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ImportProblem(ctx, req.(*ImportProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_SyncProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).SyncProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/SyncProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).SyncProblem(ctx, req.(*SyncProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/UpdateProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateProblem(ctx, req.(*UpdateProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListProblems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProblemsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListProblems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListProblems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListProblems(ctx, req.(*ListProblemsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeProblem(ctx, req.(*DescribeProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListStatements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStatementsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListStatements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListStatements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListStatements(ctx, req.(*ListStatementsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExamplesInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListExamples(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListExamples",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListExamples(ctx, req.(*ListExamplesInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DeleteProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteProblem(ctx, req.(*DeleteProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RetestProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetestProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RetestProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/RetestProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RetestProblem(ctx, req.(*RetestProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_AddParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).AddParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/AddParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).AddParticipant(ctx, req.(*AddParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_EnableParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).EnableParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/EnableParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).EnableParticipant(ctx, req.(*EnableParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DisableParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DisableParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DisableParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DisableParticipant(ctx, req.(*DisableParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_VerifyPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).VerifyPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/VerifyPasscode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).VerifyPasscode(ctx, req.(*VerifyPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_EnterPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnterPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).EnterPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/EnterPasscode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).EnterPasscode(ctx, req.(*EnterPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ResetPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ResetPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ResetPasscode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ResetPasscode(ctx, req.(*ResetPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RemovePasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RemovePasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/RemovePasscode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RemovePasscode(ctx, req.(*RemovePasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RemoveParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RemoveParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/RemoveParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RemoveParticipant(ctx, req.(*RemoveParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListParticipantsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListParticipants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListParticipants(ctx, req.(*ListParticipantsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeParticipant(ctx, req.(*DescribeParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_IntrospectParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntrospectParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).IntrospectParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/IntrospectParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).IntrospectParticipant(ctx, req.(*IntrospectParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_JoinContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).JoinContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/JoinContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).JoinContest(ctx, req.(*JoinContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_StartContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).StartContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/StartContest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).StartContest(ctx, req.(*StartContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CreateSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/CreateSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateSubmission(ctx, req.(*CreateSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubmissionsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListSubmissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListSubmissions(ctx, req.(*ListSubmissionsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeSubmission(ctx, req.(*DescribeSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RetestSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetestSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RetestSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/RetestSubmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RetestSubmission(ctx, req.(*RetestSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CreateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/CreateTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateTicket(ctx, req.(*CreateTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CloseTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CloseTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/CloseTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CloseTicket(ctx, req.(*CloseTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_OpenTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).OpenTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/OpenTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).OpenTicket(ctx, req.(*OpenTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ReadTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ReadTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ReadTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ReadTicket(ctx, req.(*ReadTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DeleteTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteTicket(ctx, req.(*DeleteTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeTicket(ctx, req.(*DescribeTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListTickets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTicketsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListTickets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListTickets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListTickets(ctx, req.(*ListTicketsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ReplyTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplyTicketInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ReplyTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ReplyTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ReplyTicket(ctx, req.(*ReplyTicketInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListReplies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRepliesInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListReplies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListReplies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListReplies(ctx, req.(*ListRepliesInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReplyInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DeleteReply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteReply(ctx, req.(*DeleteReplyInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReplyInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/UpdateReply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateReply(ctx, req.(*UpdateReplyInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CreateAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/CreateAnnouncement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateAnnouncement(ctx, req.(*CreateAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/UpdateAnnouncement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateAnnouncement(ctx, req.(*UpdateAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DeleteAnnouncement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteAnnouncement(ctx, req.(*DeleteAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ReadAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ReadAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ReadAnnouncement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ReadAnnouncement(ctx, req.(*ReadAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeAnnouncement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeAnnouncement(ctx, req.(*DescribeAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeAnnouncementStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeAnnouncementStatusInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeAnnouncementStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeAnnouncementStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeAnnouncementStatus(ctx, req.(*DescribeAnnouncementStatusInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListAnnouncements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAnnouncementsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListAnnouncements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/ListAnnouncements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListAnnouncements(ctx, req.(*ListAnnouncementsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeCodeTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeCodeTemplateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeCodeTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eolymp.judge.Judge/DescribeCodeTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeCodeTemplate(ctx, req.(*DescribeCodeTemplateInput))
	}
	return interceptor(ctx, in, info, handler)
}

// Judge_ServiceDesc is the grpc.ServiceDesc for Judge service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Judge_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eolymp.judge.Judge",
	HandlerType: (*JudgeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateContest",
			Handler:    _Judge_CreateContest_Handler,
		},
		{
			MethodName: "DeleteContest",
			Handler:    _Judge_DeleteContest_Handler,
		},
		{
			MethodName: "UpdateContest",
			Handler:    _Judge_UpdateContest_Handler,
		},
		{
			MethodName: "LookupContest",
			Handler:    _Judge_LookupContest_Handler,
		},
		{
			MethodName: "DescribeContest",
			Handler:    _Judge_DescribeContest_Handler,
		},
		{
			MethodName: "ListContests",
			Handler:    _Judge_ListContests_Handler,
		},
		{
			MethodName: "OpenContest",
			Handler:    _Judge_OpenContest_Handler,
		},
		{
			MethodName: "CloseContest",
			Handler:    _Judge_CloseContest_Handler,
		},
		{
			MethodName: "ConfigureRegistrationForm",
			Handler:    _Judge_ConfigureRegistrationForm_Handler,
		},
		{
			MethodName: "DescribeRegistrationForm",
			Handler:    _Judge_DescribeRegistrationForm_Handler,
		},
		{
			MethodName: "ConfigureRuntime",
			Handler:    _Judge_ConfigureRuntime_Handler,
		},
		{
			MethodName: "DescribeRuntime",
			Handler:    _Judge_DescribeRuntime_Handler,
		},
		{
			MethodName: "SubmitRegistration",
			Handler:    _Judge_SubmitRegistration_Handler,
		},
		{
			MethodName: "DescribeRegistration",
			Handler:    _Judge_DescribeRegistration_Handler,
		},
		{
			MethodName: "ImportProblem",
			Handler:    _Judge_ImportProblem_Handler,
		},
		{
			MethodName: "SyncProblem",
			Handler:    _Judge_SyncProblem_Handler,
		},
		{
			MethodName: "UpdateProblem",
			Handler:    _Judge_UpdateProblem_Handler,
		},
		{
			MethodName: "ListProblems",
			Handler:    _Judge_ListProblems_Handler,
		},
		{
			MethodName: "DescribeProblem",
			Handler:    _Judge_DescribeProblem_Handler,
		},
		{
			MethodName: "ListStatements",
			Handler:    _Judge_ListStatements_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Judge_ListExamples_Handler,
		},
		{
			MethodName: "DeleteProblem",
			Handler:    _Judge_DeleteProblem_Handler,
		},
		{
			MethodName: "RetestProblem",
			Handler:    _Judge_RetestProblem_Handler,
		},
		{
			MethodName: "AddParticipant",
			Handler:    _Judge_AddParticipant_Handler,
		},
		{
			MethodName: "EnableParticipant",
			Handler:    _Judge_EnableParticipant_Handler,
		},
		{
			MethodName: "DisableParticipant",
			Handler:    _Judge_DisableParticipant_Handler,
		},
		{
			MethodName: "VerifyPasscode",
			Handler:    _Judge_VerifyPasscode_Handler,
		},
		{
			MethodName: "EnterPasscode",
			Handler:    _Judge_EnterPasscode_Handler,
		},
		{
			MethodName: "ResetPasscode",
			Handler:    _Judge_ResetPasscode_Handler,
		},
		{
			MethodName: "RemovePasscode",
			Handler:    _Judge_RemovePasscode_Handler,
		},
		{
			MethodName: "RemoveParticipant",
			Handler:    _Judge_RemoveParticipant_Handler,
		},
		{
			MethodName: "ListParticipants",
			Handler:    _Judge_ListParticipants_Handler,
		},
		{
			MethodName: "DescribeParticipant",
			Handler:    _Judge_DescribeParticipant_Handler,
		},
		{
			MethodName: "IntrospectParticipant",
			Handler:    _Judge_IntrospectParticipant_Handler,
		},
		{
			MethodName: "JoinContest",
			Handler:    _Judge_JoinContest_Handler,
		},
		{
			MethodName: "StartContest",
			Handler:    _Judge_StartContest_Handler,
		},
		{
			MethodName: "CreateSubmission",
			Handler:    _Judge_CreateSubmission_Handler,
		},
		{
			MethodName: "ListSubmissions",
			Handler:    _Judge_ListSubmissions_Handler,
		},
		{
			MethodName: "DescribeSubmission",
			Handler:    _Judge_DescribeSubmission_Handler,
		},
		{
			MethodName: "RetestSubmission",
			Handler:    _Judge_RetestSubmission_Handler,
		},
		{
			MethodName: "CreateTicket",
			Handler:    _Judge_CreateTicket_Handler,
		},
		{
			MethodName: "CloseTicket",
			Handler:    _Judge_CloseTicket_Handler,
		},
		{
			MethodName: "OpenTicket",
			Handler:    _Judge_OpenTicket_Handler,
		},
		{
			MethodName: "ReadTicket",
			Handler:    _Judge_ReadTicket_Handler,
		},
		{
			MethodName: "DeleteTicket",
			Handler:    _Judge_DeleteTicket_Handler,
		},
		{
			MethodName: "DescribeTicket",
			Handler:    _Judge_DescribeTicket_Handler,
		},
		{
			MethodName: "ListTickets",
			Handler:    _Judge_ListTickets_Handler,
		},
		{
			MethodName: "ReplyTicket",
			Handler:    _Judge_ReplyTicket_Handler,
		},
		{
			MethodName: "ListReplies",
			Handler:    _Judge_ListReplies_Handler,
		},
		{
			MethodName: "DeleteReply",
			Handler:    _Judge_DeleteReply_Handler,
		},
		{
			MethodName: "UpdateReply",
			Handler:    _Judge_UpdateReply_Handler,
		},
		{
			MethodName: "CreateAnnouncement",
			Handler:    _Judge_CreateAnnouncement_Handler,
		},
		{
			MethodName: "UpdateAnnouncement",
			Handler:    _Judge_UpdateAnnouncement_Handler,
		},
		{
			MethodName: "DeleteAnnouncement",
			Handler:    _Judge_DeleteAnnouncement_Handler,
		},
		{
			MethodName: "ReadAnnouncement",
			Handler:    _Judge_ReadAnnouncement_Handler,
		},
		{
			MethodName: "DescribeAnnouncement",
			Handler:    _Judge_DescribeAnnouncement_Handler,
		},
		{
			MethodName: "DescribeAnnouncementStatus",
			Handler:    _Judge_DescribeAnnouncementStatus_Handler,
		},
		{
			MethodName: "ListAnnouncements",
			Handler:    _Judge_ListAnnouncements_Handler,
		},
		{
			MethodName: "DescribeCodeTemplate",
			Handler:    _Judge_DescribeCodeTemplate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eolymp/judge/judge.proto",
}
