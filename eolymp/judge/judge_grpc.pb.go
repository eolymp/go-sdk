// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: eolymp/judge/judge.proto

package judge

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Judge_CreateContest_FullMethodName              = "/eolymp.judge.Judge/CreateContest"
	Judge_DeleteContest_FullMethodName              = "/eolymp.judge.Judge/DeleteContest"
	Judge_UpdateContest_FullMethodName              = "/eolymp.judge.Judge/UpdateContest"
	Judge_DescribeContest_FullMethodName            = "/eolymp.judge.Judge/DescribeContest"
	Judge_ListContests_FullMethodName               = "/eolymp.judge.Judge/ListContests"
	Judge_OpenContest_FullMethodName                = "/eolymp.judge.Judge/OpenContest"
	Judge_CloseContest_FullMethodName               = "/eolymp.judge.Judge/CloseContest"
	Judge_SuspendContest_FullMethodName             = "/eolymp.judge.Judge/SuspendContest"
	Judge_FreezeContest_FullMethodName              = "/eolymp.judge.Judge/FreezeContest"
	Judge_ResumeContest_FullMethodName              = "/eolymp.judge.Judge/ResumeContest"
	Judge_ImportProblem_FullMethodName              = "/eolymp.judge.Judge/ImportProblem"
	Judge_SyncProblem_FullMethodName                = "/eolymp.judge.Judge/SyncProblem"
	Judge_UpdateProblem_FullMethodName              = "/eolymp.judge.Judge/UpdateProblem"
	Judge_ListProblems_FullMethodName               = "/eolymp.judge.Judge/ListProblems"
	Judge_DescribeProblem_FullMethodName            = "/eolymp.judge.Judge/DescribeProblem"
	Judge_DescribeCodeTemplate_FullMethodName       = "/eolymp.judge.Judge/DescribeCodeTemplate"
	Judge_LookupCodeTemplate_FullMethodName         = "/eolymp.judge.Judge/LookupCodeTemplate"
	Judge_ListStatements_FullMethodName             = "/eolymp.judge.Judge/ListStatements"
	Judge_ListAttachments_FullMethodName            = "/eolymp.judge.Judge/ListAttachments"
	Judge_ListExamples_FullMethodName               = "/eolymp.judge.Judge/ListExamples"
	Judge_DeleteProblem_FullMethodName              = "/eolymp.judge.Judge/DeleteProblem"
	Judge_RetestProblem_FullMethodName              = "/eolymp.judge.Judge/RetestProblem"
	Judge_AddParticipant_FullMethodName             = "/eolymp.judge.Judge/AddParticipant"
	Judge_EnableParticipant_FullMethodName          = "/eolymp.judge.Judge/EnableParticipant"
	Judge_DisableParticipant_FullMethodName         = "/eolymp.judge.Judge/DisableParticipant"
	Judge_UpdateParticipant_FullMethodName          = "/eolymp.judge.Judge/UpdateParticipant"
	Judge_DeleteParticipant_FullMethodName          = "/eolymp.judge.Judge/DeleteParticipant"
	Judge_ListParticipants_FullMethodName           = "/eolymp.judge.Judge/ListParticipants"
	Judge_DescribeParticipant_FullMethodName        = "/eolymp.judge.Judge/DescribeParticipant"
	Judge_DescribeViewer_FullMethodName             = "/eolymp.judge.Judge/DescribeViewer"
	Judge_JoinContest_FullMethodName                = "/eolymp.judge.Judge/JoinContest"
	Judge_StartContest_FullMethodName               = "/eolymp.judge.Judge/StartContest"
	Judge_VerifyPasscode_FullMethodName             = "/eolymp.judge.Judge/VerifyPasscode"
	Judge_EnterPasscode_FullMethodName              = "/eolymp.judge.Judge/EnterPasscode"
	Judge_ResetPasscode_FullMethodName              = "/eolymp.judge.Judge/ResetPasscode"
	Judge_SetPasscode_FullMethodName                = "/eolymp.judge.Judge/SetPasscode"
	Judge_RemovePasscode_FullMethodName             = "/eolymp.judge.Judge/RemovePasscode"
	Judge_CreateSubmission_FullMethodName           = "/eolymp.judge.Judge/CreateSubmission"
	Judge_ListSubmissions_FullMethodName            = "/eolymp.judge.Judge/ListSubmissions"
	Judge_DescribeSubmission_FullMethodName         = "/eolymp.judge.Judge/DescribeSubmission"
	Judge_WatchSubmission_FullMethodName            = "/eolymp.judge.Judge/WatchSubmission"
	Judge_RetestSubmission_FullMethodName           = "/eolymp.judge.Judge/RetestSubmission"
	Judge_DeleteSubmission_FullMethodName           = "/eolymp.judge.Judge/DeleteSubmission"
	Judge_RestoreSubmission_FullMethodName          = "/eolymp.judge.Judge/RestoreSubmission"
	Judge_CreateAnnouncement_FullMethodName         = "/eolymp.judge.Judge/CreateAnnouncement"
	Judge_UpdateAnnouncement_FullMethodName         = "/eolymp.judge.Judge/UpdateAnnouncement"
	Judge_DeleteAnnouncement_FullMethodName         = "/eolymp.judge.Judge/DeleteAnnouncement"
	Judge_ReadAnnouncement_FullMethodName           = "/eolymp.judge.Judge/ReadAnnouncement"
	Judge_DescribeAnnouncement_FullMethodName       = "/eolymp.judge.Judge/DescribeAnnouncement"
	Judge_DescribeAnnouncementStatus_FullMethodName = "/eolymp.judge.Judge/DescribeAnnouncementStatus"
	Judge_ListAnnouncements_FullMethodName          = "/eolymp.judge.Judge/ListAnnouncements"
	Judge_IntrospectScore_FullMethodName            = "/eolymp.judge.Judge/IntrospectScore"
	Judge_DescribeScore_FullMethodName              = "/eolymp.judge.Judge/DescribeScore"
	Judge_ImportScore_FullMethodName                = "/eolymp.judge.Judge/ImportScore"
	Judge_ExportScore_FullMethodName                = "/eolymp.judge.Judge/ExportScore"
	Judge_ListResult_FullMethodName                 = "/eolymp.judge.Judge/ListResult"
	Judge_RebuildScore_FullMethodName               = "/eolymp.judge.Judge/RebuildScore"
	Judge_ListActivities_FullMethodName             = "/eolymp.judge.Judge/ListActivities"
	Judge_DescribeContestUsage_FullMethodName       = "/eolymp.judge.Judge/DescribeContestUsage"
)

// JudgeClient is the client API for Judge service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JudgeClient interface {
	CreateContest(ctx context.Context, in *CreateContestInput, opts ...grpc.CallOption) (*CreateContestOutput, error)
	DeleteContest(ctx context.Context, in *DeleteContestInput, opts ...grpc.CallOption) (*DeleteContestOutput, error)
	UpdateContest(ctx context.Context, in *UpdateContestInput, opts ...grpc.CallOption) (*UpdateContestOutput, error)
	DescribeContest(ctx context.Context, in *DescribeContestInput, opts ...grpc.CallOption) (*DescribeContestOutput, error)
	ListContests(ctx context.Context, in *ListContestsInput, opts ...grpc.CallOption) (*ListContestsOutput, error)
	// Force-starts scheduled contest, this call also automatically changes starts_at to current time and adjusts
	// ends_at to match original date range of the contest.
	OpenContest(ctx context.Context, in *OpenContestInput, opts ...grpc.CallOption) (*OpenContestOutput, error)
	// Force-finishes open contest, this method automatically changes ends_at to current time.
	CloseContest(ctx context.Context, in *CloseContestInput, opts ...grpc.CallOption) (*CloseContestOutput, error)
	// Temporarily stop contest and block participant's interface
	// Use ResumeContest to switch contest back to a normal mode.
	SuspendContest(ctx context.Context, in *SuspendContestInput, opts ...grpc.CallOption) (*SuspendContestOutput, error)
	// Temporarily restrict submission function
	// Use ResumeContest to switch contest back to a normal mode.
	FreezeContest(ctx context.Context, in *FreezeContestInput, opts ...grpc.CallOption) (*FreezeContestOutput, error)
	// Re-start suspended or frozen contest
	ResumeContest(ctx context.Context, in *ResumeContestInput, opts ...grpc.CallOption) (*ResumeContestOutput, error)
	// ImportProblem from Atlas (problem catalog)
	ImportProblem(ctx context.Context, in *ImportProblemInput, opts ...grpc.CallOption) (*ImportProblemOutput, error)
	// SyncProblem with Atlas (problem catalog)
	SyncProblem(ctx context.Context, in *SyncProblemInput, opts ...grpc.CallOption) (*SyncProblemOutput, error)
	UpdateProblem(ctx context.Context, in *UpdateProblemInput, opts ...grpc.CallOption) (*UpdateProblemOutput, error)
	ListProblems(ctx context.Context, in *ListProblemsInput, opts ...grpc.CallOption) (*ListProblemsOutput, error)
	DescribeProblem(ctx context.Context, in *DescribeProblemInput, opts ...grpc.CallOption) (*DescribeProblemOutput, error)
	// Return code template for problem
	DescribeCodeTemplate(ctx context.Context, in *DescribeCodeTemplateInput, opts ...grpc.CallOption) (*DescribeCodeTemplateOutput, error)
	// Lookup template for a given runtime/language
	LookupCodeTemplate(ctx context.Context, in *LookupCodeTemplateInput, opts ...grpc.CallOption) (*LookupCodeTemplateOutput, error)
	ListStatements(ctx context.Context, in *ListStatementsInput, opts ...grpc.CallOption) (*ListStatementsOutput, error)
	ListAttachments(ctx context.Context, in *ListAttachmentsInput, opts ...grpc.CallOption) (*ListAttachmentsOutput, error)
	ListExamples(ctx context.Context, in *ListExamplesInput, opts ...grpc.CallOption) (*ListExamplesOutput, error)
	DeleteProblem(ctx context.Context, in *DeleteProblemInput, opts ...grpc.CallOption) (*DeleteProblemOutput, error)
	// RetestProblem resets existing submissions for the problem and triggers testing process again.
	RetestProblem(ctx context.Context, in *RetestProblemInput, opts ...grpc.CallOption) (*RetestProblemOutput, error)
	AddParticipant(ctx context.Context, in *AssignParticipantInput, opts ...grpc.CallOption) (*AssignParticipantOutput, error)
	EnableParticipant(ctx context.Context, in *EnableParticipantInput, opts ...grpc.CallOption) (*EnableParticipantOutput, error)
	DisableParticipant(ctx context.Context, in *DisableParticipantInput, opts ...grpc.CallOption) (*DisableParticipantOutput, error)
	UpdateParticipant(ctx context.Context, in *UpdateParticipantInput, opts ...grpc.CallOption) (*UpdateParticipantOutput, error)
	DeleteParticipant(ctx context.Context, in *DeleteParticipantInput, opts ...grpc.CallOption) (*DeleteParticipantOutput, error)
	ListParticipants(ctx context.Context, in *ListParticipantsInput, opts ...grpc.CallOption) (*ListParticipantsOutput, error)
	DescribeParticipant(ctx context.Context, in *DescribeParticipantInput, opts ...grpc.CallOption) (*DescribeParticipantOutput, error)
	// DescribeViewer allows to fetch participant data for a currently authorized user.
	DescribeViewer(ctx context.Context, in *DescribeViewerInput, opts ...grpc.CallOption) (*DescribeViewerOutput, error)
	// Allows a participant (currently authorized user) to join (add himself to) a public contest.
	JoinContest(ctx context.Context, in *JoinContestInput, opts ...grpc.CallOption) (*JoinContestOutput, error)
	// Allows a participant (currently authorized user) to start participating in the contest, see problems and submit solutions.
	StartContest(ctx context.Context, in *StartContestInput, opts ...grpc.CallOption) (*StartContestOutput, error)
	// Verify if passcode is required for the contest and if authenticated token has entered the passcode.
	VerifyPasscode(ctx context.Context, in *VerifyPasscodeInput, opts ...grpc.CallOption) (*VerifyPasscodeOutput, error)
	// Enter passcode marks current session as one authenticated by passcode.
	EnterPasscode(ctx context.Context, in *EnterPasscodeInput, opts ...grpc.CallOption) (*EnterPasscodeOutput, error)
	// Set a new passcode to the participant, if passcode was not set it will be now required
	ResetPasscode(ctx context.Context, in *ResetPasscodeInput, opts ...grpc.CallOption) (*ResetPasscodeOutput, error)
	// Set a new passcode to the participant, if passcode was not set it will be now required
	SetPasscode(ctx context.Context, in *SetPasscodeInput, opts ...grpc.CallOption) (*SetPasscodeOutput, error)
	// Remove passcode from participant and allow her to enter contest without passcode.
	RemovePasscode(ctx context.Context, in *RemovePasscodeInput, opts ...grpc.CallOption) (*RemovePasscodeOutput, error)
	// Creates submissions and triggers test process.
	CreateSubmission(ctx context.Context, in *CreateSubmissionInput, opts ...grpc.CallOption) (*CreateSubmissionOutput, error)
	ListSubmissions(ctx context.Context, in *ListSubmissionsInput, opts ...grpc.CallOption) (*ListSubmissionsOutput, error)
	DescribeSubmission(ctx context.Context, in *DescribeSubmissionInput, opts ...grpc.CallOption) (*DescribeSubmissionOutput, error)
	WatchSubmission(ctx context.Context, in *WatchSubmissionInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchSubmissionOutput], error)
	// Resets submission results and triggers testing process.
	RetestSubmission(ctx context.Context, in *RetestSubmissionInput, opts ...grpc.CallOption) (*RetestSubmissionOutput, error)
	DeleteSubmission(ctx context.Context, in *DeleteSubmissionInput, opts ...grpc.CallOption) (*DeleteSubmissionOutput, error)
	RestoreSubmission(ctx context.Context, in *RestoreSubmissionInput, opts ...grpc.CallOption) (*RestoreSubmissionOutput, error)
	// Create announcement for a contest
	CreateAnnouncement(ctx context.Context, in *CreateAnnouncementInput, opts ...grpc.CallOption) (*CreateAnnouncementOutput, error)
	// Update existing announcement in a contest
	UpdateAnnouncement(ctx context.Context, in *UpdateAnnouncementInput, opts ...grpc.CallOption) (*UpdateAnnouncementOutput, error)
	// Delete announcement
	DeleteAnnouncement(ctx context.Context, in *DeleteAnnouncementInput, opts ...grpc.CallOption) (*DeleteAnnouncementOutput, error)
	// Mark announcement as read by authenticated participant
	ReadAnnouncement(ctx context.Context, in *ReadAnnouncementInput, opts ...grpc.CallOption) (*ReadAnnouncementOutput, error)
	// Describe announcement
	DescribeAnnouncement(ctx context.Context, in *DescribeAnnouncementInput, opts ...grpc.CallOption) (*DescribeAnnouncementOutput, error)
	// Describe announcement status
	DescribeAnnouncementStatus(ctx context.Context, in *DescribeAnnouncementStatusInput, opts ...grpc.CallOption) (*DescribeAnnouncementStatusOutput, error)
	// List announcements of a contest
	ListAnnouncements(ctx context.Context, in *ListAnnouncementsInput, opts ...grpc.CallOption) (*ListAnnouncementsOutput, error)
	IntrospectScore(ctx context.Context, in *IntrospectScoreInput, opts ...grpc.CallOption) (*IntrospectScoreOutput, error)
	DescribeScore(ctx context.Context, in *DescribeScoreInput, opts ...grpc.CallOption) (*DescribeScoreOutput, error)
	// ImportScore for ghost participants
	ImportScore(ctx context.Context, in *ImportScoreInput, opts ...grpc.CallOption) (*ImportScoreOutput, error)
	// ExportScore for ghost participants
	ExportScore(ctx context.Context, in *ExportScoreInput, opts ...grpc.CallOption) (*ExportScoreOutput, error)
	// ListResult retrieves scoreboard
	ListResult(ctx context.Context, in *ListResultInput, opts ...grpc.CallOption) (*ListResultOutput, error)
	// Rebuild scoreboard
	RebuildScore(ctx context.Context, in *RebuildScoreInput, opts ...grpc.CallOption) (*RebuildScoreOutput, error)
	ListActivities(ctx context.Context, in *ListActivitiesInput, opts ...grpc.CallOption) (*ListActivitiesOutput, error)
	DescribeContestUsage(ctx context.Context, in *DescribeContestUsageInput, opts ...grpc.CallOption) (*DescribeContestUsageOutput, error)
}

type judgeClient struct {
	cc grpc.ClientConnInterface
}

func NewJudgeClient(cc grpc.ClientConnInterface) JudgeClient {
	return &judgeClient{cc}
}

func (c *judgeClient) CreateContest(ctx context.Context, in *CreateContestInput, opts ...grpc.CallOption) (*CreateContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateContestOutput)
	err := c.cc.Invoke(ctx, Judge_CreateContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteContest(ctx context.Context, in *DeleteContestInput, opts ...grpc.CallOption) (*DeleteContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteContestOutput)
	err := c.cc.Invoke(ctx, Judge_DeleteContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateContest(ctx context.Context, in *UpdateContestInput, opts ...grpc.CallOption) (*UpdateContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateContestOutput)
	err := c.cc.Invoke(ctx, Judge_UpdateContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeContest(ctx context.Context, in *DescribeContestInput, opts ...grpc.CallOption) (*DescribeContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeContestOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListContests(ctx context.Context, in *ListContestsInput, opts ...grpc.CallOption) (*ListContestsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListContestsOutput)
	err := c.cc.Invoke(ctx, Judge_ListContests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) OpenContest(ctx context.Context, in *OpenContestInput, opts ...grpc.CallOption) (*OpenContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenContestOutput)
	err := c.cc.Invoke(ctx, Judge_OpenContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CloseContest(ctx context.Context, in *CloseContestInput, opts ...grpc.CallOption) (*CloseContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseContestOutput)
	err := c.cc.Invoke(ctx, Judge_CloseContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) SuspendContest(ctx context.Context, in *SuspendContestInput, opts ...grpc.CallOption) (*SuspendContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuspendContestOutput)
	err := c.cc.Invoke(ctx, Judge_SuspendContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) FreezeContest(ctx context.Context, in *FreezeContestInput, opts ...grpc.CallOption) (*FreezeContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FreezeContestOutput)
	err := c.cc.Invoke(ctx, Judge_FreezeContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ResumeContest(ctx context.Context, in *ResumeContestInput, opts ...grpc.CallOption) (*ResumeContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeContestOutput)
	err := c.cc.Invoke(ctx, Judge_ResumeContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ImportProblem(ctx context.Context, in *ImportProblemInput, opts ...grpc.CallOption) (*ImportProblemOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportProblemOutput)
	err := c.cc.Invoke(ctx, Judge_ImportProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) SyncProblem(ctx context.Context, in *SyncProblemInput, opts ...grpc.CallOption) (*SyncProblemOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncProblemOutput)
	err := c.cc.Invoke(ctx, Judge_SyncProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateProblem(ctx context.Context, in *UpdateProblemInput, opts ...grpc.CallOption) (*UpdateProblemOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProblemOutput)
	err := c.cc.Invoke(ctx, Judge_UpdateProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListProblems(ctx context.Context, in *ListProblemsInput, opts ...grpc.CallOption) (*ListProblemsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProblemsOutput)
	err := c.cc.Invoke(ctx, Judge_ListProblems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeProblem(ctx context.Context, in *DescribeProblemInput, opts ...grpc.CallOption) (*DescribeProblemOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeProblemOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeCodeTemplate(ctx context.Context, in *DescribeCodeTemplateInput, opts ...grpc.CallOption) (*DescribeCodeTemplateOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeCodeTemplateOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeCodeTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) LookupCodeTemplate(ctx context.Context, in *LookupCodeTemplateInput, opts ...grpc.CallOption) (*LookupCodeTemplateOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupCodeTemplateOutput)
	err := c.cc.Invoke(ctx, Judge_LookupCodeTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListStatements(ctx context.Context, in *ListStatementsInput, opts ...grpc.CallOption) (*ListStatementsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStatementsOutput)
	err := c.cc.Invoke(ctx, Judge_ListStatements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListAttachments(ctx context.Context, in *ListAttachmentsInput, opts ...grpc.CallOption) (*ListAttachmentsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAttachmentsOutput)
	err := c.cc.Invoke(ctx, Judge_ListAttachments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListExamples(ctx context.Context, in *ListExamplesInput, opts ...grpc.CallOption) (*ListExamplesOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExamplesOutput)
	err := c.cc.Invoke(ctx, Judge_ListExamples_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteProblem(ctx context.Context, in *DeleteProblemInput, opts ...grpc.CallOption) (*DeleteProblemOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProblemOutput)
	err := c.cc.Invoke(ctx, Judge_DeleteProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RetestProblem(ctx context.Context, in *RetestProblemInput, opts ...grpc.CallOption) (*RetestProblemOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetestProblemOutput)
	err := c.cc.Invoke(ctx, Judge_RetestProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) AddParticipant(ctx context.Context, in *AssignParticipantInput, opts ...grpc.CallOption) (*AssignParticipantOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssignParticipantOutput)
	err := c.cc.Invoke(ctx, Judge_AddParticipant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) EnableParticipant(ctx context.Context, in *EnableParticipantInput, opts ...grpc.CallOption) (*EnableParticipantOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableParticipantOutput)
	err := c.cc.Invoke(ctx, Judge_EnableParticipant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DisableParticipant(ctx context.Context, in *DisableParticipantInput, opts ...grpc.CallOption) (*DisableParticipantOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableParticipantOutput)
	err := c.cc.Invoke(ctx, Judge_DisableParticipant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateParticipant(ctx context.Context, in *UpdateParticipantInput, opts ...grpc.CallOption) (*UpdateParticipantOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateParticipantOutput)
	err := c.cc.Invoke(ctx, Judge_UpdateParticipant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteParticipant(ctx context.Context, in *DeleteParticipantInput, opts ...grpc.CallOption) (*DeleteParticipantOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteParticipantOutput)
	err := c.cc.Invoke(ctx, Judge_DeleteParticipant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListParticipants(ctx context.Context, in *ListParticipantsInput, opts ...grpc.CallOption) (*ListParticipantsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListParticipantsOutput)
	err := c.cc.Invoke(ctx, Judge_ListParticipants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeParticipant(ctx context.Context, in *DescribeParticipantInput, opts ...grpc.CallOption) (*DescribeParticipantOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeParticipantOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeParticipant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeViewer(ctx context.Context, in *DescribeViewerInput, opts ...grpc.CallOption) (*DescribeViewerOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeViewerOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeViewer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) JoinContest(ctx context.Context, in *JoinContestInput, opts ...grpc.CallOption) (*JoinContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinContestOutput)
	err := c.cc.Invoke(ctx, Judge_JoinContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) StartContest(ctx context.Context, in *StartContestInput, opts ...grpc.CallOption) (*StartContestOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartContestOutput)
	err := c.cc.Invoke(ctx, Judge_StartContest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) VerifyPasscode(ctx context.Context, in *VerifyPasscodeInput, opts ...grpc.CallOption) (*VerifyPasscodeOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyPasscodeOutput)
	err := c.cc.Invoke(ctx, Judge_VerifyPasscode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) EnterPasscode(ctx context.Context, in *EnterPasscodeInput, opts ...grpc.CallOption) (*EnterPasscodeOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnterPasscodeOutput)
	err := c.cc.Invoke(ctx, Judge_EnterPasscode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ResetPasscode(ctx context.Context, in *ResetPasscodeInput, opts ...grpc.CallOption) (*ResetPasscodeOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasscodeOutput)
	err := c.cc.Invoke(ctx, Judge_ResetPasscode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) SetPasscode(ctx context.Context, in *SetPasscodeInput, opts ...grpc.CallOption) (*SetPasscodeOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPasscodeOutput)
	err := c.cc.Invoke(ctx, Judge_SetPasscode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RemovePasscode(ctx context.Context, in *RemovePasscodeInput, opts ...grpc.CallOption) (*RemovePasscodeOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePasscodeOutput)
	err := c.cc.Invoke(ctx, Judge_RemovePasscode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CreateSubmission(ctx context.Context, in *CreateSubmissionInput, opts ...grpc.CallOption) (*CreateSubmissionOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSubmissionOutput)
	err := c.cc.Invoke(ctx, Judge_CreateSubmission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListSubmissions(ctx context.Context, in *ListSubmissionsInput, opts ...grpc.CallOption) (*ListSubmissionsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSubmissionsOutput)
	err := c.cc.Invoke(ctx, Judge_ListSubmissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeSubmission(ctx context.Context, in *DescribeSubmissionInput, opts ...grpc.CallOption) (*DescribeSubmissionOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeSubmissionOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeSubmission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) WatchSubmission(ctx context.Context, in *WatchSubmissionInput, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchSubmissionOutput], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Judge_ServiceDesc.Streams[0], Judge_WatchSubmission_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchSubmissionInput, WatchSubmissionOutput]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Judge_WatchSubmissionClient = grpc.ServerStreamingClient[WatchSubmissionOutput]

func (c *judgeClient) RetestSubmission(ctx context.Context, in *RetestSubmissionInput, opts ...grpc.CallOption) (*RetestSubmissionOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetestSubmissionOutput)
	err := c.cc.Invoke(ctx, Judge_RetestSubmission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteSubmission(ctx context.Context, in *DeleteSubmissionInput, opts ...grpc.CallOption) (*DeleteSubmissionOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSubmissionOutput)
	err := c.cc.Invoke(ctx, Judge_DeleteSubmission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RestoreSubmission(ctx context.Context, in *RestoreSubmissionInput, opts ...grpc.CallOption) (*RestoreSubmissionOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreSubmissionOutput)
	err := c.cc.Invoke(ctx, Judge_RestoreSubmission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) CreateAnnouncement(ctx context.Context, in *CreateAnnouncementInput, opts ...grpc.CallOption) (*CreateAnnouncementOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAnnouncementOutput)
	err := c.cc.Invoke(ctx, Judge_CreateAnnouncement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) UpdateAnnouncement(ctx context.Context, in *UpdateAnnouncementInput, opts ...grpc.CallOption) (*UpdateAnnouncementOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAnnouncementOutput)
	err := c.cc.Invoke(ctx, Judge_UpdateAnnouncement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DeleteAnnouncement(ctx context.Context, in *DeleteAnnouncementInput, opts ...grpc.CallOption) (*DeleteAnnouncementOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAnnouncementOutput)
	err := c.cc.Invoke(ctx, Judge_DeleteAnnouncement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ReadAnnouncement(ctx context.Context, in *ReadAnnouncementInput, opts ...grpc.CallOption) (*ReadAnnouncementOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadAnnouncementOutput)
	err := c.cc.Invoke(ctx, Judge_ReadAnnouncement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeAnnouncement(ctx context.Context, in *DescribeAnnouncementInput, opts ...grpc.CallOption) (*DescribeAnnouncementOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeAnnouncementOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeAnnouncement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeAnnouncementStatus(ctx context.Context, in *DescribeAnnouncementStatusInput, opts ...grpc.CallOption) (*DescribeAnnouncementStatusOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeAnnouncementStatusOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeAnnouncementStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListAnnouncements(ctx context.Context, in *ListAnnouncementsInput, opts ...grpc.CallOption) (*ListAnnouncementsOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAnnouncementsOutput)
	err := c.cc.Invoke(ctx, Judge_ListAnnouncements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) IntrospectScore(ctx context.Context, in *IntrospectScoreInput, opts ...grpc.CallOption) (*IntrospectScoreOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntrospectScoreOutput)
	err := c.cc.Invoke(ctx, Judge_IntrospectScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeScore(ctx context.Context, in *DescribeScoreInput, opts ...grpc.CallOption) (*DescribeScoreOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeScoreOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ImportScore(ctx context.Context, in *ImportScoreInput, opts ...grpc.CallOption) (*ImportScoreOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportScoreOutput)
	err := c.cc.Invoke(ctx, Judge_ImportScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ExportScore(ctx context.Context, in *ExportScoreInput, opts ...grpc.CallOption) (*ExportScoreOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportScoreOutput)
	err := c.cc.Invoke(ctx, Judge_ExportScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListResult(ctx context.Context, in *ListResultInput, opts ...grpc.CallOption) (*ListResultOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResultOutput)
	err := c.cc.Invoke(ctx, Judge_ListResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) RebuildScore(ctx context.Context, in *RebuildScoreInput, opts ...grpc.CallOption) (*RebuildScoreOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RebuildScoreOutput)
	err := c.cc.Invoke(ctx, Judge_RebuildScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) ListActivities(ctx context.Context, in *ListActivitiesInput, opts ...grpc.CallOption) (*ListActivitiesOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActivitiesOutput)
	err := c.cc.Invoke(ctx, Judge_ListActivities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *judgeClient) DescribeContestUsage(ctx context.Context, in *DescribeContestUsageInput, opts ...grpc.CallOption) (*DescribeContestUsageOutput, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeContestUsageOutput)
	err := c.cc.Invoke(ctx, Judge_DescribeContestUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JudgeServer is the server API for Judge service.
// All implementations should embed UnimplementedJudgeServer
// for forward compatibility.
type JudgeServer interface {
	CreateContest(context.Context, *CreateContestInput) (*CreateContestOutput, error)
	DeleteContest(context.Context, *DeleteContestInput) (*DeleteContestOutput, error)
	UpdateContest(context.Context, *UpdateContestInput) (*UpdateContestOutput, error)
	DescribeContest(context.Context, *DescribeContestInput) (*DescribeContestOutput, error)
	ListContests(context.Context, *ListContestsInput) (*ListContestsOutput, error)
	// Force-starts scheduled contest, this call also automatically changes starts_at to current time and adjusts
	// ends_at to match original date range of the contest.
	OpenContest(context.Context, *OpenContestInput) (*OpenContestOutput, error)
	// Force-finishes open contest, this method automatically changes ends_at to current time.
	CloseContest(context.Context, *CloseContestInput) (*CloseContestOutput, error)
	// Temporarily stop contest and block participant's interface
	// Use ResumeContest to switch contest back to a normal mode.
	SuspendContest(context.Context, *SuspendContestInput) (*SuspendContestOutput, error)
	// Temporarily restrict submission function
	// Use ResumeContest to switch contest back to a normal mode.
	FreezeContest(context.Context, *FreezeContestInput) (*FreezeContestOutput, error)
	// Re-start suspended or frozen contest
	ResumeContest(context.Context, *ResumeContestInput) (*ResumeContestOutput, error)
	// ImportProblem from Atlas (problem catalog)
	ImportProblem(context.Context, *ImportProblemInput) (*ImportProblemOutput, error)
	// SyncProblem with Atlas (problem catalog)
	SyncProblem(context.Context, *SyncProblemInput) (*SyncProblemOutput, error)
	UpdateProblem(context.Context, *UpdateProblemInput) (*UpdateProblemOutput, error)
	ListProblems(context.Context, *ListProblemsInput) (*ListProblemsOutput, error)
	DescribeProblem(context.Context, *DescribeProblemInput) (*DescribeProblemOutput, error)
	// Return code template for problem
	DescribeCodeTemplate(context.Context, *DescribeCodeTemplateInput) (*DescribeCodeTemplateOutput, error)
	// Lookup template for a given runtime/language
	LookupCodeTemplate(context.Context, *LookupCodeTemplateInput) (*LookupCodeTemplateOutput, error)
	ListStatements(context.Context, *ListStatementsInput) (*ListStatementsOutput, error)
	ListAttachments(context.Context, *ListAttachmentsInput) (*ListAttachmentsOutput, error)
	ListExamples(context.Context, *ListExamplesInput) (*ListExamplesOutput, error)
	DeleteProblem(context.Context, *DeleteProblemInput) (*DeleteProblemOutput, error)
	// RetestProblem resets existing submissions for the problem and triggers testing process again.
	RetestProblem(context.Context, *RetestProblemInput) (*RetestProblemOutput, error)
	AddParticipant(context.Context, *AssignParticipantInput) (*AssignParticipantOutput, error)
	EnableParticipant(context.Context, *EnableParticipantInput) (*EnableParticipantOutput, error)
	DisableParticipant(context.Context, *DisableParticipantInput) (*DisableParticipantOutput, error)
	UpdateParticipant(context.Context, *UpdateParticipantInput) (*UpdateParticipantOutput, error)
	DeleteParticipant(context.Context, *DeleteParticipantInput) (*DeleteParticipantOutput, error)
	ListParticipants(context.Context, *ListParticipantsInput) (*ListParticipantsOutput, error)
	DescribeParticipant(context.Context, *DescribeParticipantInput) (*DescribeParticipantOutput, error)
	// DescribeViewer allows to fetch participant data for a currently authorized user.
	DescribeViewer(context.Context, *DescribeViewerInput) (*DescribeViewerOutput, error)
	// Allows a participant (currently authorized user) to join (add himself to) a public contest.
	JoinContest(context.Context, *JoinContestInput) (*JoinContestOutput, error)
	// Allows a participant (currently authorized user) to start participating in the contest, see problems and submit solutions.
	StartContest(context.Context, *StartContestInput) (*StartContestOutput, error)
	// Verify if passcode is required for the contest and if authenticated token has entered the passcode.
	VerifyPasscode(context.Context, *VerifyPasscodeInput) (*VerifyPasscodeOutput, error)
	// Enter passcode marks current session as one authenticated by passcode.
	EnterPasscode(context.Context, *EnterPasscodeInput) (*EnterPasscodeOutput, error)
	// Set a new passcode to the participant, if passcode was not set it will be now required
	ResetPasscode(context.Context, *ResetPasscodeInput) (*ResetPasscodeOutput, error)
	// Set a new passcode to the participant, if passcode was not set it will be now required
	SetPasscode(context.Context, *SetPasscodeInput) (*SetPasscodeOutput, error)
	// Remove passcode from participant and allow her to enter contest without passcode.
	RemovePasscode(context.Context, *RemovePasscodeInput) (*RemovePasscodeOutput, error)
	// Creates submissions and triggers test process.
	CreateSubmission(context.Context, *CreateSubmissionInput) (*CreateSubmissionOutput, error)
	ListSubmissions(context.Context, *ListSubmissionsInput) (*ListSubmissionsOutput, error)
	DescribeSubmission(context.Context, *DescribeSubmissionInput) (*DescribeSubmissionOutput, error)
	WatchSubmission(*WatchSubmissionInput, grpc.ServerStreamingServer[WatchSubmissionOutput]) error
	// Resets submission results and triggers testing process.
	RetestSubmission(context.Context, *RetestSubmissionInput) (*RetestSubmissionOutput, error)
	DeleteSubmission(context.Context, *DeleteSubmissionInput) (*DeleteSubmissionOutput, error)
	RestoreSubmission(context.Context, *RestoreSubmissionInput) (*RestoreSubmissionOutput, error)
	// Create announcement for a contest
	CreateAnnouncement(context.Context, *CreateAnnouncementInput) (*CreateAnnouncementOutput, error)
	// Update existing announcement in a contest
	UpdateAnnouncement(context.Context, *UpdateAnnouncementInput) (*UpdateAnnouncementOutput, error)
	// Delete announcement
	DeleteAnnouncement(context.Context, *DeleteAnnouncementInput) (*DeleteAnnouncementOutput, error)
	// Mark announcement as read by authenticated participant
	ReadAnnouncement(context.Context, *ReadAnnouncementInput) (*ReadAnnouncementOutput, error)
	// Describe announcement
	DescribeAnnouncement(context.Context, *DescribeAnnouncementInput) (*DescribeAnnouncementOutput, error)
	// Describe announcement status
	DescribeAnnouncementStatus(context.Context, *DescribeAnnouncementStatusInput) (*DescribeAnnouncementStatusOutput, error)
	// List announcements of a contest
	ListAnnouncements(context.Context, *ListAnnouncementsInput) (*ListAnnouncementsOutput, error)
	IntrospectScore(context.Context, *IntrospectScoreInput) (*IntrospectScoreOutput, error)
	DescribeScore(context.Context, *DescribeScoreInput) (*DescribeScoreOutput, error)
	// ImportScore for ghost participants
	ImportScore(context.Context, *ImportScoreInput) (*ImportScoreOutput, error)
	// ExportScore for ghost participants
	ExportScore(context.Context, *ExportScoreInput) (*ExportScoreOutput, error)
	// ListResult retrieves scoreboard
	ListResult(context.Context, *ListResultInput) (*ListResultOutput, error)
	// Rebuild scoreboard
	RebuildScore(context.Context, *RebuildScoreInput) (*RebuildScoreOutput, error)
	ListActivities(context.Context, *ListActivitiesInput) (*ListActivitiesOutput, error)
	DescribeContestUsage(context.Context, *DescribeContestUsageInput) (*DescribeContestUsageOutput, error)
}

// UnimplementedJudgeServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJudgeServer struct{}

func (UnimplementedJudgeServer) CreateContest(context.Context, *CreateContestInput) (*CreateContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContest not implemented")
}
func (UnimplementedJudgeServer) DeleteContest(context.Context, *DeleteContestInput) (*DeleteContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteContest not implemented")
}
func (UnimplementedJudgeServer) UpdateContest(context.Context, *UpdateContestInput) (*UpdateContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateContest not implemented")
}
func (UnimplementedJudgeServer) DescribeContest(context.Context, *DescribeContestInput) (*DescribeContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeContest not implemented")
}
func (UnimplementedJudgeServer) ListContests(context.Context, *ListContestsInput) (*ListContestsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContests not implemented")
}
func (UnimplementedJudgeServer) OpenContest(context.Context, *OpenContestInput) (*OpenContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenContest not implemented")
}
func (UnimplementedJudgeServer) CloseContest(context.Context, *CloseContestInput) (*CloseContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseContest not implemented")
}
func (UnimplementedJudgeServer) SuspendContest(context.Context, *SuspendContestInput) (*SuspendContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspendContest not implemented")
}
func (UnimplementedJudgeServer) FreezeContest(context.Context, *FreezeContestInput) (*FreezeContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FreezeContest not implemented")
}
func (UnimplementedJudgeServer) ResumeContest(context.Context, *ResumeContestInput) (*ResumeContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeContest not implemented")
}
func (UnimplementedJudgeServer) ImportProblem(context.Context, *ImportProblemInput) (*ImportProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportProblem not implemented")
}
func (UnimplementedJudgeServer) SyncProblem(context.Context, *SyncProblemInput) (*SyncProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncProblem not implemented")
}
func (UnimplementedJudgeServer) UpdateProblem(context.Context, *UpdateProblemInput) (*UpdateProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProblem not implemented")
}
func (UnimplementedJudgeServer) ListProblems(context.Context, *ListProblemsInput) (*ListProblemsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProblems not implemented")
}
func (UnimplementedJudgeServer) DescribeProblem(context.Context, *DescribeProblemInput) (*DescribeProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeProblem not implemented")
}
func (UnimplementedJudgeServer) DescribeCodeTemplate(context.Context, *DescribeCodeTemplateInput) (*DescribeCodeTemplateOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeCodeTemplate not implemented")
}
func (UnimplementedJudgeServer) LookupCodeTemplate(context.Context, *LookupCodeTemplateInput) (*LookupCodeTemplateOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupCodeTemplate not implemented")
}
func (UnimplementedJudgeServer) ListStatements(context.Context, *ListStatementsInput) (*ListStatementsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStatements not implemented")
}
func (UnimplementedJudgeServer) ListAttachments(context.Context, *ListAttachmentsInput) (*ListAttachmentsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAttachments not implemented")
}
func (UnimplementedJudgeServer) ListExamples(context.Context, *ListExamplesInput) (*ListExamplesOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExamples not implemented")
}
func (UnimplementedJudgeServer) DeleteProblem(context.Context, *DeleteProblemInput) (*DeleteProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProblem not implemented")
}
func (UnimplementedJudgeServer) RetestProblem(context.Context, *RetestProblemInput) (*RetestProblemOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetestProblem not implemented")
}
func (UnimplementedJudgeServer) AddParticipant(context.Context, *AssignParticipantInput) (*AssignParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddParticipant not implemented")
}
func (UnimplementedJudgeServer) EnableParticipant(context.Context, *EnableParticipantInput) (*EnableParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableParticipant not implemented")
}
func (UnimplementedJudgeServer) DisableParticipant(context.Context, *DisableParticipantInput) (*DisableParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableParticipant not implemented")
}
func (UnimplementedJudgeServer) UpdateParticipant(context.Context, *UpdateParticipantInput) (*UpdateParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParticipant not implemented")
}
func (UnimplementedJudgeServer) DeleteParticipant(context.Context, *DeleteParticipantInput) (*DeleteParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteParticipant not implemented")
}
func (UnimplementedJudgeServer) ListParticipants(context.Context, *ListParticipantsInput) (*ListParticipantsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListParticipants not implemented")
}
func (UnimplementedJudgeServer) DescribeParticipant(context.Context, *DescribeParticipantInput) (*DescribeParticipantOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeParticipant not implemented")
}
func (UnimplementedJudgeServer) DescribeViewer(context.Context, *DescribeViewerInput) (*DescribeViewerOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeViewer not implemented")
}
func (UnimplementedJudgeServer) JoinContest(context.Context, *JoinContestInput) (*JoinContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinContest not implemented")
}
func (UnimplementedJudgeServer) StartContest(context.Context, *StartContestInput) (*StartContestOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartContest not implemented")
}
func (UnimplementedJudgeServer) VerifyPasscode(context.Context, *VerifyPasscodeInput) (*VerifyPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyPasscode not implemented")
}
func (UnimplementedJudgeServer) EnterPasscode(context.Context, *EnterPasscodeInput) (*EnterPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnterPasscode not implemented")
}
func (UnimplementedJudgeServer) ResetPasscode(context.Context, *ResetPasscodeInput) (*ResetPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPasscode not implemented")
}
func (UnimplementedJudgeServer) SetPasscode(context.Context, *SetPasscodeInput) (*SetPasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPasscode not implemented")
}
func (UnimplementedJudgeServer) RemovePasscode(context.Context, *RemovePasscodeInput) (*RemovePasscodeOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePasscode not implemented")
}
func (UnimplementedJudgeServer) CreateSubmission(context.Context, *CreateSubmissionInput) (*CreateSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubmission not implemented")
}
func (UnimplementedJudgeServer) ListSubmissions(context.Context, *ListSubmissionsInput) (*ListSubmissionsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubmissions not implemented")
}
func (UnimplementedJudgeServer) DescribeSubmission(context.Context, *DescribeSubmissionInput) (*DescribeSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeSubmission not implemented")
}
func (UnimplementedJudgeServer) WatchSubmission(*WatchSubmissionInput, grpc.ServerStreamingServer[WatchSubmissionOutput]) error {
	return status.Errorf(codes.Unimplemented, "method WatchSubmission not implemented")
}
func (UnimplementedJudgeServer) RetestSubmission(context.Context, *RetestSubmissionInput) (*RetestSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetestSubmission not implemented")
}
func (UnimplementedJudgeServer) DeleteSubmission(context.Context, *DeleteSubmissionInput) (*DeleteSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubmission not implemented")
}
func (UnimplementedJudgeServer) RestoreSubmission(context.Context, *RestoreSubmissionInput) (*RestoreSubmissionOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreSubmission not implemented")
}
func (UnimplementedJudgeServer) CreateAnnouncement(context.Context, *CreateAnnouncementInput) (*CreateAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAnnouncement not implemented")
}
func (UnimplementedJudgeServer) UpdateAnnouncement(context.Context, *UpdateAnnouncementInput) (*UpdateAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAnnouncement not implemented")
}
func (UnimplementedJudgeServer) DeleteAnnouncement(context.Context, *DeleteAnnouncementInput) (*DeleteAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAnnouncement not implemented")
}
func (UnimplementedJudgeServer) ReadAnnouncement(context.Context, *ReadAnnouncementInput) (*ReadAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAnnouncement not implemented")
}
func (UnimplementedJudgeServer) DescribeAnnouncement(context.Context, *DescribeAnnouncementInput) (*DescribeAnnouncementOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeAnnouncement not implemented")
}
func (UnimplementedJudgeServer) DescribeAnnouncementStatus(context.Context, *DescribeAnnouncementStatusInput) (*DescribeAnnouncementStatusOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeAnnouncementStatus not implemented")
}
func (UnimplementedJudgeServer) ListAnnouncements(context.Context, *ListAnnouncementsInput) (*ListAnnouncementsOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAnnouncements not implemented")
}
func (UnimplementedJudgeServer) IntrospectScore(context.Context, *IntrospectScoreInput) (*IntrospectScoreOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntrospectScore not implemented")
}
func (UnimplementedJudgeServer) DescribeScore(context.Context, *DescribeScoreInput) (*DescribeScoreOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeScore not implemented")
}
func (UnimplementedJudgeServer) ImportScore(context.Context, *ImportScoreInput) (*ImportScoreOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportScore not implemented")
}
func (UnimplementedJudgeServer) ExportScore(context.Context, *ExportScoreInput) (*ExportScoreOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportScore not implemented")
}
func (UnimplementedJudgeServer) ListResult(context.Context, *ListResultInput) (*ListResultOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListResult not implemented")
}
func (UnimplementedJudgeServer) RebuildScore(context.Context, *RebuildScoreInput) (*RebuildScoreOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildScore not implemented")
}
func (UnimplementedJudgeServer) ListActivities(context.Context, *ListActivitiesInput) (*ListActivitiesOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListActivities not implemented")
}
func (UnimplementedJudgeServer) DescribeContestUsage(context.Context, *DescribeContestUsageInput) (*DescribeContestUsageOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeContestUsage not implemented")
}
func (UnimplementedJudgeServer) testEmbeddedByValue() {}

// UnsafeJudgeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JudgeServer will
// result in compilation errors.
type UnsafeJudgeServer interface {
	mustEmbedUnimplementedJudgeServer()
}

func RegisterJudgeServer(s grpc.ServiceRegistrar, srv JudgeServer) {
	// If the following call pancis, it indicates UnimplementedJudgeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Judge_ServiceDesc, srv)
}

func _Judge_CreateContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_CreateContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateContest(ctx, req.(*CreateContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DeleteContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteContest(ctx, req.(*DeleteContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_UpdateContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateContest(ctx, req.(*UpdateContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeContest(ctx, req.(*DescribeContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListContests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContestsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListContests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListContests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListContests(ctx, req.(*ListContestsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_OpenContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).OpenContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_OpenContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).OpenContest(ctx, req.(*OpenContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CloseContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CloseContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_CloseContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CloseContest(ctx, req.(*CloseContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_SuspendContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).SuspendContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_SuspendContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).SuspendContest(ctx, req.(*SuspendContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_FreezeContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreezeContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).FreezeContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_FreezeContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).FreezeContest(ctx, req.(*FreezeContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ResumeContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ResumeContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ResumeContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ResumeContest(ctx, req.(*ResumeContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ImportProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ImportProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ImportProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ImportProblem(ctx, req.(*ImportProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_SyncProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).SyncProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_SyncProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).SyncProblem(ctx, req.(*SyncProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_UpdateProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateProblem(ctx, req.(*UpdateProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListProblems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProblemsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListProblems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListProblems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListProblems(ctx, req.(*ListProblemsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeProblem(ctx, req.(*DescribeProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeCodeTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeCodeTemplateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeCodeTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeCodeTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeCodeTemplate(ctx, req.(*DescribeCodeTemplateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_LookupCodeTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupCodeTemplateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).LookupCodeTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_LookupCodeTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).LookupCodeTemplate(ctx, req.(*LookupCodeTemplateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListStatements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStatementsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListStatements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListStatements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListStatements(ctx, req.(*ListStatementsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListAttachments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAttachmentsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListAttachments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListAttachments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListAttachments(ctx, req.(*ListAttachmentsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExamplesInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListExamples(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListExamples_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListExamples(ctx, req.(*ListExamplesInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DeleteProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteProblem(ctx, req.(*DeleteProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RetestProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetestProblemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RetestProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_RetestProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RetestProblem(ctx, req.(*RetestProblemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_AddParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).AddParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_AddParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).AddParticipant(ctx, req.(*AssignParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_EnableParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).EnableParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_EnableParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).EnableParticipant(ctx, req.(*EnableParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DisableParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DisableParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DisableParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DisableParticipant(ctx, req.(*DisableParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_UpdateParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateParticipant(ctx, req.(*UpdateParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DeleteParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteParticipant(ctx, req.(*DeleteParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListParticipantsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListParticipants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListParticipants(ctx, req.(*ListParticipantsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeParticipantInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeParticipant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeParticipant(ctx, req.(*DescribeParticipantInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeViewer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeViewerInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeViewer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeViewer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeViewer(ctx, req.(*DescribeViewerInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_JoinContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).JoinContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_JoinContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).JoinContest(ctx, req.(*JoinContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_StartContest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartContestInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).StartContest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_StartContest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).StartContest(ctx, req.(*StartContestInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_VerifyPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).VerifyPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_VerifyPasscode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).VerifyPasscode(ctx, req.(*VerifyPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_EnterPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnterPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).EnterPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_EnterPasscode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).EnterPasscode(ctx, req.(*EnterPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ResetPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ResetPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ResetPasscode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ResetPasscode(ctx, req.(*ResetPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_SetPasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).SetPasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_SetPasscode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).SetPasscode(ctx, req.(*SetPasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RemovePasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePasscodeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RemovePasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_RemovePasscode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RemovePasscode(ctx, req.(*RemovePasscodeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CreateSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_CreateSubmission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateSubmission(ctx, req.(*CreateSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListSubmissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubmissionsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListSubmissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListSubmissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListSubmissions(ctx, req.(*ListSubmissionsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeSubmission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeSubmission(ctx, req.(*DescribeSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_WatchSubmission_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSubmissionInput)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JudgeServer).WatchSubmission(m, &grpc.GenericServerStream[WatchSubmissionInput, WatchSubmissionOutput]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Judge_WatchSubmissionServer = grpc.ServerStreamingServer[WatchSubmissionOutput]

func _Judge_RetestSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetestSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RetestSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_RetestSubmission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RetestSubmission(ctx, req.(*RetestSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DeleteSubmission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteSubmission(ctx, req.(*DeleteSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RestoreSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreSubmissionInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RestoreSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_RestoreSubmission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RestoreSubmission(ctx, req.(*RestoreSubmissionInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_CreateAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).CreateAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_CreateAnnouncement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).CreateAnnouncement(ctx, req.(*CreateAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_UpdateAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).UpdateAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_UpdateAnnouncement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).UpdateAnnouncement(ctx, req.(*UpdateAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DeleteAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DeleteAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DeleteAnnouncement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DeleteAnnouncement(ctx, req.(*DeleteAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ReadAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ReadAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ReadAnnouncement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ReadAnnouncement(ctx, req.(*ReadAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeAnnouncement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeAnnouncementInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeAnnouncement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeAnnouncement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeAnnouncement(ctx, req.(*DescribeAnnouncementInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeAnnouncementStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeAnnouncementStatusInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeAnnouncementStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeAnnouncementStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeAnnouncementStatus(ctx, req.(*DescribeAnnouncementStatusInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListAnnouncements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAnnouncementsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListAnnouncements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListAnnouncements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListAnnouncements(ctx, req.(*ListAnnouncementsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_IntrospectScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntrospectScoreInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).IntrospectScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_IntrospectScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).IntrospectScore(ctx, req.(*IntrospectScoreInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeScoreInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeScore(ctx, req.(*DescribeScoreInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ImportScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportScoreInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ImportScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ImportScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ImportScore(ctx, req.(*ImportScoreInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ExportScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportScoreInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ExportScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ExportScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ExportScore(ctx, req.(*ExportScoreInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResultInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListResult(ctx, req.(*ListResultInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_RebuildScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebuildScoreInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).RebuildScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_RebuildScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).RebuildScore(ctx, req.(*RebuildScoreInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_ListActivities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActivitiesInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).ListActivities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_ListActivities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).ListActivities(ctx, req.(*ListActivitiesInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Judge_DescribeContestUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeContestUsageInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JudgeServer).DescribeContestUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Judge_DescribeContestUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JudgeServer).DescribeContestUsage(ctx, req.(*DescribeContestUsageInput))
	}
	return interceptor(ctx, in, info, handler)
}

// Judge_ServiceDesc is the grpc.ServiceDesc for Judge service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Judge_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eolymp.judge.Judge",
	HandlerType: (*JudgeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateContest",
			Handler:    _Judge_CreateContest_Handler,
		},
		{
			MethodName: "DeleteContest",
			Handler:    _Judge_DeleteContest_Handler,
		},
		{
			MethodName: "UpdateContest",
			Handler:    _Judge_UpdateContest_Handler,
		},
		{
			MethodName: "DescribeContest",
			Handler:    _Judge_DescribeContest_Handler,
		},
		{
			MethodName: "ListContests",
			Handler:    _Judge_ListContests_Handler,
		},
		{
			MethodName: "OpenContest",
			Handler:    _Judge_OpenContest_Handler,
		},
		{
			MethodName: "CloseContest",
			Handler:    _Judge_CloseContest_Handler,
		},
		{
			MethodName: "SuspendContest",
			Handler:    _Judge_SuspendContest_Handler,
		},
		{
			MethodName: "FreezeContest",
			Handler:    _Judge_FreezeContest_Handler,
		},
		{
			MethodName: "ResumeContest",
			Handler:    _Judge_ResumeContest_Handler,
		},
		{
			MethodName: "ImportProblem",
			Handler:    _Judge_ImportProblem_Handler,
		},
		{
			MethodName: "SyncProblem",
			Handler:    _Judge_SyncProblem_Handler,
		},
		{
			MethodName: "UpdateProblem",
			Handler:    _Judge_UpdateProblem_Handler,
		},
		{
			MethodName: "ListProblems",
			Handler:    _Judge_ListProblems_Handler,
		},
		{
			MethodName: "DescribeProblem",
			Handler:    _Judge_DescribeProblem_Handler,
		},
		{
			MethodName: "DescribeCodeTemplate",
			Handler:    _Judge_DescribeCodeTemplate_Handler,
		},
		{
			MethodName: "LookupCodeTemplate",
			Handler:    _Judge_LookupCodeTemplate_Handler,
		},
		{
			MethodName: "ListStatements",
			Handler:    _Judge_ListStatements_Handler,
		},
		{
			MethodName: "ListAttachments",
			Handler:    _Judge_ListAttachments_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Judge_ListExamples_Handler,
		},
		{
			MethodName: "DeleteProblem",
			Handler:    _Judge_DeleteProblem_Handler,
		},
		{
			MethodName: "RetestProblem",
			Handler:    _Judge_RetestProblem_Handler,
		},
		{
			MethodName: "AddParticipant",
			Handler:    _Judge_AddParticipant_Handler,
		},
		{
			MethodName: "EnableParticipant",
			Handler:    _Judge_EnableParticipant_Handler,
		},
		{
			MethodName: "DisableParticipant",
			Handler:    _Judge_DisableParticipant_Handler,
		},
		{
			MethodName: "UpdateParticipant",
			Handler:    _Judge_UpdateParticipant_Handler,
		},
		{
			MethodName: "DeleteParticipant",
			Handler:    _Judge_DeleteParticipant_Handler,
		},
		{
			MethodName: "ListParticipants",
			Handler:    _Judge_ListParticipants_Handler,
		},
		{
			MethodName: "DescribeParticipant",
			Handler:    _Judge_DescribeParticipant_Handler,
		},
		{
			MethodName: "DescribeViewer",
			Handler:    _Judge_DescribeViewer_Handler,
		},
		{
			MethodName: "JoinContest",
			Handler:    _Judge_JoinContest_Handler,
		},
		{
			MethodName: "StartContest",
			Handler:    _Judge_StartContest_Handler,
		},
		{
			MethodName: "VerifyPasscode",
			Handler:    _Judge_VerifyPasscode_Handler,
		},
		{
			MethodName: "EnterPasscode",
			Handler:    _Judge_EnterPasscode_Handler,
		},
		{
			MethodName: "ResetPasscode",
			Handler:    _Judge_ResetPasscode_Handler,
		},
		{
			MethodName: "SetPasscode",
			Handler:    _Judge_SetPasscode_Handler,
		},
		{
			MethodName: "RemovePasscode",
			Handler:    _Judge_RemovePasscode_Handler,
		},
		{
			MethodName: "CreateSubmission",
			Handler:    _Judge_CreateSubmission_Handler,
		},
		{
			MethodName: "ListSubmissions",
			Handler:    _Judge_ListSubmissions_Handler,
		},
		{
			MethodName: "DescribeSubmission",
			Handler:    _Judge_DescribeSubmission_Handler,
		},
		{
			MethodName: "RetestSubmission",
			Handler:    _Judge_RetestSubmission_Handler,
		},
		{
			MethodName: "DeleteSubmission",
			Handler:    _Judge_DeleteSubmission_Handler,
		},
		{
			MethodName: "RestoreSubmission",
			Handler:    _Judge_RestoreSubmission_Handler,
		},
		{
			MethodName: "CreateAnnouncement",
			Handler:    _Judge_CreateAnnouncement_Handler,
		},
		{
			MethodName: "UpdateAnnouncement",
			Handler:    _Judge_UpdateAnnouncement_Handler,
		},
		{
			MethodName: "DeleteAnnouncement",
			Handler:    _Judge_DeleteAnnouncement_Handler,
		},
		{
			MethodName: "ReadAnnouncement",
			Handler:    _Judge_ReadAnnouncement_Handler,
		},
		{
			MethodName: "DescribeAnnouncement",
			Handler:    _Judge_DescribeAnnouncement_Handler,
		},
		{
			MethodName: "DescribeAnnouncementStatus",
			Handler:    _Judge_DescribeAnnouncementStatus_Handler,
		},
		{
			MethodName: "ListAnnouncements",
			Handler:    _Judge_ListAnnouncements_Handler,
		},
		{
			MethodName: "IntrospectScore",
			Handler:    _Judge_IntrospectScore_Handler,
		},
		{
			MethodName: "DescribeScore",
			Handler:    _Judge_DescribeScore_Handler,
		},
		{
			MethodName: "ImportScore",
			Handler:    _Judge_ImportScore_Handler,
		},
		{
			MethodName: "ExportScore",
			Handler:    _Judge_ExportScore_Handler,
		},
		{
			MethodName: "ListResult",
			Handler:    _Judge_ListResult_Handler,
		},
		{
			MethodName: "RebuildScore",
			Handler:    _Judge_RebuildScore_Handler,
		},
		{
			MethodName: "ListActivities",
			Handler:    _Judge_ListActivities_Handler,
		},
		{
			MethodName: "DescribeContestUsage",
			Handler:    _Judge_DescribeContestUsage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSubmission",
			Handler:       _Judge_WatchSubmission_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "eolymp/judge/judge.proto",
}
